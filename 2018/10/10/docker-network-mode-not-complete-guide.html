<!DOCTYPE html>
<html lang=zh-CN class="bg-gray-100">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:description" content="吹雨听风独立博客">
<meta property="og:type" content="website">

<meta name="description" content="吹雨听风独立博客">


<meta name="keyword"  content="">

<link rel="shortcut icon" href="/img/favicon.ico">

<link rel="stylesheet" href="/css/tailwind.css">


<link rel="stylesheet" href="/css/typo.css">


<link rel="stylesheet" href="/css/theme.css">

<script type="text/javascript" src="/js/theme.js?v="></script>
<title>
    
        Docker 网络模式不完全指南 - 吹雨听风
    
</title>    

<body>

<div class="index-container py-2 md:py-8 px-2 md:px-0">
    <div class="main-content-wrapper max-w-4xl m-auto bg-white pt-8 pb-6 px-10">
        <header class="">
    <div class="max-w-4xl mx-auto">
        <div class="py-4 border-b border-slate-900/10 border-0 dark:border-slate-300/10 mx-0">
            <div class="relative sm:flex sm:items-center">
                <div class="flex-none sm:flex-initial">
                    <a class="flex-none overflow-hidden md:w-auto" href="/.">
                        <span class="text-xl font-bold">吹雨听风</span>
                    </a>

                    
                        <span class="hidden md:inline-block text-xs text-gray-500"><i> - 热爱写代码. </i></span>
                    
                </div>

                <div class="flex-none sm:flex-auto flex items-center sm:justify-end lg:w-0 space-x-4">
    

    

    

    
</div>
            </div>
        </div>
    </div>
</header>

        
        

        <main>
            
<article class="max-w-4xl mx-auto py-10 typo">
    <h1 style="margin-top: 0;">
        Docker 网络模式不完全指南
    </h1>

    <div>
        <div class="flex">
                <span>
                    <time datetime="Wed Oct 10 2018 00:00:00 GMT+0000">2018-10-10</time>
                </span>

            

            
        </div>

        
            <div class="mt-2">
                <span>Tags：</span>
                
                    <a class="" href="/tags/#技术"
                       title="技术">技术</a>
                    
                        <span>,</span>
                    
                
                    <a class="" href="/tags/#Docker"
                       title="Docker">Docker</a>
                    
                        <span>,</span>
                    
                
                    <a class="" href="/tags/#HTTPS"
                       title="HTTPS">HTTPS</a>
                    
                        <span>,</span>
                    
                
                    <a class="" href="/tags/#网络"
                       title="网络">网络</a>
                    
                
            </div>
        
    </div>

    <section class="pt-10 ">
        <p>本次分享没有：</p>
<ul>
<li>Docker的背景</li>
<li>Docker的整体架构</li>
<li>Docker的核心实现技术</li>
<li>Docker的高级用法</li>
<li>Docker的使用秘笈</li>
</ul>
<p>本次分享是：<br><em>Docker使用中的…</em><br><em>一条命令的…</em><br><em>一个参数的..</em><br><em>不完全说明.</em></p>
<h3 id="Docker网络模式"><a href="#Docker网络模式" class="headerlink" title="Docker网络模式"></a>Docker网络模式</h3><p>一般文章中说的网络模式，其实主要是指 <code>docker run</code> 命令的 <code>--net</code> 或 <code>--network</code> 参数所支持的模式，默认包括：</p>
<ol>
<li>bridge模式（划重点，最后说）<br> 使用 <code>--network=bridge</code> 指定，默认设置可不指定</li>
<li>host模式<br> 使用 <code>--network=host</code> 指定</li>
<li>container模式<br> 使用 <code>--network=container:NAME_or_ID</code> 指定</li>
<li>none模式<br> 使用 <code>--network=none</code> 指定</li>
</ol>
<p>有时网络模式也会包括其他的模式，例如 <a target="_blank" rel="noopener" href="https://docs.docker.com/network/macvlan/">macvlan</a>、<a target="_blank" rel="noopener" href="https://docs.docker.com/network/overlay/">overlay</a> 等，这些并不仅通过上述参数指定，属于高级用法，如有需要可查阅文档。<br>这里只介绍常见的上述4种模式。</p>
<h4 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h4><p>容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</p>
<ul>
<li>试验<br>创建容器：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -d --network host --name my_nginx nginx</span><br></pre></td></tr></table></figure>
在宿主机检查端口监听情况：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -tulpn | grep :80</span><br></pre></td></tr></table></figure></li>
</ul>
<p>通过这种模式，一些命令行工具可以很方便地通过docker来使用，避免在宿主机安装大量的依赖包，也便于随时清理。例如启动一个 tcpdump 的容器抓取主机上的网络报文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=host -v $PWD:/data corfr/tcpdump -i any -w /data/dump.pcap &quot;icmp&quot;</span><br></pre></td></tr></table></figure>

<h4 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h4><p>在了解了 host 模式后，这个模式也就好理解了。这个模式创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。<br>kubernetes 的 pod 可以认为就是用这个实现的（？），同一个 pod 中的容器共享一个 network namespace。</p>
<ul>
<li>试验<br>我们运行两个 nginx 容器：web1 和 web2：<br>web1 监听在 80 端口，使用默认的网络模型<br>web2 监听在 8080 端口，使用 container 网络模型共享 web1 的网络<br>先启动 web1，通过端口映射把端口绑定到主机上：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=web1 -p 80:80 nginx</span><br></pre></td></tr></table></figure>
使用 curl 命令验证容器运行正常：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:80</span><br></pre></td></tr></table></figure>
第二个容器和 host 模式相同，使用 –net 参数让新建的容器使用 web1 的网络：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=web2 -v $&#123;PWD&#125;/default.conf:/etc/nginx/sites-available/default -v $&#123;PWD&#125;/index.html:/var/www/html/index.html -d --net=container:web1 nginx</span><br></pre></td></tr></table></figure>
其中 <code>default.conf</code> 文件就是修改了 nginx 默认配置文件的端口，把它变成 8080；<code>inedx.html</code> 可以随便修改一点，以区别于默认的内容。<br>在 web1 或 web2 容器里面可以验证 nginx 服务：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8080</span><br></pre></td></tr></table></figure>
在两个容器中，可以分别通过 <code>ip addr</code> 查看网络配置，是完全一致的（命令和执行结果从略）。</li>
</ul>
<h4 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h4><p>这个模式和前两个不同。在这种模式下，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。<br>选择这种模式，一般是用户对网络有自己特殊的需求，不希望 docker 预设置太多的东西。</p>
<h4 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h4><p>在默认的bridge模式下，docker 会在宿主机上新创建一个网桥，可以把它想象成一个虚拟的交换机，所有的容器都是连到这台交换机上面的。docker 会从私有网络中选择一段地址来管理容器，比如 172.17.0.1&#x2F;16（这个地址根据你之前的网络情况而有所不同）。通过网桥，让容器的子网可以访问宿主机所连接的外网，并且可以通过 <strong>端口映射</strong> 来实现容器对外暴露端口提供服务（即外部可以通过宿主机、网桥访问容器上的服务）。这是最常用的网络模式，又分为以下两种情况：</p>
<ol>
<li>使用默认网络</li>
</ol>
<p>默认的网络docker将其称为 <code>bridge</code> 网络，在这种情况下，容器可以相互通信（若出于安全考虑，也可以禁止它们之间通信，方法是在 <code>DOCKER_OPTS</code> 变量中设置 <code>--icc=false</code>，这样只有使用 <code>--link</code> 选项才能使两个容器通信，关于 <code>--link</code> 后面还会说到）。<br>容器可以访问外部网络，但是Docker容器的IP、网络等对外是不可见的。即外部服务发现的访问客户端IP，是宿主机IP而不是容器IP。<br>而通过端口映射，可以让外部访问Docker容器的服务。</p>
<ul>
<li>试验<br>我们首先用下面命令创建一个含有 web 应用的容器，将容器的 80 端口映射到主机的 80 端口。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -d --name web -p 80:80 nginx</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果宿主机的IP为10.10.101.105，外界只需访问10.10.101.105:80 就可以访问到容器中的服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://10.10.101.105:80</span><br></pre></td></tr></table></figure>
<p>查看默认的网络</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect bridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;aeeabedfaa07ae4d06d0dad4ede4126a93e0efd9a2a5f0034551665aa2744976&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-29T03:25:10.046595598Z&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;1a30155cb661730fe5733a20ca8f692da0ce9edae1932b902399ed31e4b42cbd&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;web&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;2d2009eb67cd56b9a40bea4d43be87d45fd61994a85e27fd0546494d065cfd3b&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自行创建网络</li>
</ol>
<p>这种情况与使用默认网络基本类似，只是通过命令创建自有的网络和网桥来实现通信，这样就可以自己规划网络拓扑。在建立开发环境时，这是很常用的一种方式。laradock 即采用这种方式。</p>
<ul>
<li>试验<br>创建一个名为 <code>web-net</code> 的自定义网络，使用bridge网络驱动：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge web-net</span><br></pre></td></tr></table></figure></li>
</ul>
<p>查看一下已经创建的网络列表，可以看到除了docker自行创建的 <code>bridge</code> 网络，还有刚创建的 <code>web-net</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>

<p>查看 <code>web-net</code> 网络的详细信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect web-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;web-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;79be842fea854d32708498bb01bf67e3b4967ffe32405493be2f1c6424eb4752&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-29T06:57:23.58969899Z&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>创建两个容器，使用 <code>web-net</code> 网络：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -d --name web1 --network web-net nginx</span><br><span class="line">docker run --rm -d --name web2 --network web-net nginx</span><br></pre></td></tr></table></figure>

<p>再次查看 <code>web-net</code> 网络的详细信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect web-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;web-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;79be842fea854d32708498bb01bf67e3b4967ffe32405493be2f1c6424eb4752&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-29T06:57:23.58969899Z&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;614b91e2000356945a1aba29cfa4dacad04f0bf254972c78a54aacd3663079ca&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;web1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;d0254e60f67f6d5eb155731bb028c40a2b723b0ef2aacfbe641b96dd67ca5a75&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;6aa947097ca8b6189c7a057b545ff718a82b15df4212cad6ee1ce3f2031e4bb5&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;web2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;9be085bf7f3d075f4224b285d7a3c4c382b516c22698a151c1049ea9298ee567&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>可见容器 <code>web1</code> 和 <code>web2</code> 已经加入了此网络，并且分配了各自的网络IP，并使用同一个网络和网关。</p>
<h4 id="bridge模式下默认网络和自建网络的差别"><a href="#bridge模式下默认网络和自建网络的差别" class="headerlink" title="bridge模式下默认网络和自建网络的差别"></a>bridge模式下默认网络和自建网络的差别</h4><ol>
<li>提供更好的网络隔离和更灵活的拓扑</li>
</ol>
<p>这一点不言而喻，只是需了解：各容器的全部端口，对当前网络（不论是默认还是自建）内的其他容器完全开放，而对宿主机和外界都不开放，除非设置端口映射。</p>
<ol start="2">
<li>自建网络自动提供了各容器名称的DNS解析</li>
</ol>
<p>默认网络下，各容器只能通过IP访问，除非显式设置 <a target="_blank" rel="noopener" href="https://docs.docker.com/network/links/">–link 选项</a><br>而在自建网络中，默认就可以在某个容器中通过容器的名称来访问其他容器。</p>
<ol start="3">
<li><p>容器可以动态的（无需重启容器）加入自建网络或移除（通过 <code>docker network connect</code> 或 <code>docker network disconnect</code> ，而如果要加入或移除默认网络，需要重建容器。</p>
</li>
<li><p>每个自建网络拥有自己的可配置的网桥，可以进行更灵活的网桥参数配置。</p>
</li>
<li><p>在默认网络并通过 <code>--link</code> 选项连接的容器可以共享环境变量，但在自建网络中不行。</p>
</li>
</ol>
<h3 id="Docker实现"><a href="#Docker实现" class="headerlink" title="Docker实现"></a>Docker实现</h3><p>Docker的网络模式实际上是基于网络驱动来实现的，要了解网络驱动，需要先了解Docker的网络模型架构。<br>Docker的网络架构基于称为 <strong>容器网络模型 Container Networking Model (CNM)</strong> 的一组接口来实现：</p>
<p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485228_49.png" alt="图片描述"></p>
<p>图中以Docker Engine为界，上半部分（高层网络设施）是下半部分（驱动）的处理实例。</p>
<p>CNM与网络驱动的结构和关系：</p>
<p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485279_69.png" alt="图片描述"></p>
<p>另外还需了解的是：Docker 使用了 Linux 的 <a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17010.html">Namespaces</a> 技术来进行资源隔离，如 PID Namespace 隔离进程，Mount Namespace 隔离文件系统，Network Namespace 隔离网络等。一个 Network Namespace 提供了一份独立的网络环境，包括网卡、路由、Iptable 规则等都与其他的 Network Namespace 隔离。</p>
<ol>
<li>Host驱动<br>  在Host驱动模式下，docker 不会为容器创建单独的网络 namespace，而是共享主机的 network namespace，也就是说：容器可以直接访问主机上所有的网络信息。</li>
</ol>
<p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485300_42.png" alt="图片描述"></p>
<ol>
<li>Bridge驱动（默认网络）<br>  在Bridge驱动模式下，如果不自行建立网络（ <code>docker network create ...</code> ），会直接使用docker自建的默认网络。docker会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</li>
</ol>
<p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485329_29.png" alt="图片描述"></p>
<p>Docker 完成以上网络配置的过程大致是这样的：<br>在主机上创建一对虚拟网卡 veth pair 设备。veth 设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth 设备常用来连接两个网络设备。Docker 将 veth pair 设备的一端放在新创建的容器中，并命名为 eth0。另一端放在主机中，以 veth65f9 这样类似的名字命名，并将这个网络设备加入到 docker0 网桥中，可以通过 brctl show 命令查看。</p>
<p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485347_11.png" alt="图片描述"></p>
<p>从 docker0 子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的默认网关。</p>
<ol start="3">
<li>Bridge驱动（自建网络）</li>
</ol>
<p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485354_79.png" alt="图片描述"></p>
<p>与默认网络的区别在于，自行创建了网桥和一个或多个子网。</p>
<ol start="4">
<li>Overlay、MACVLAN、None从略，如需了解请查阅 <a target="_blank" rel="noopener" href="https://success.docker.com/article/networking">官方文档</a></li>
</ol>
<p>一些细节说明：</p>
<ol>
<li>host&#x2F;bridge模式分别基于Host&#x2F;Bridge驱动实现，这很好理解。那么container模式呢？</li>
</ol>
<p>实际上container模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，因此可以认为是使用“别人”的驱动来实现。</p>
<ol start="2">
<li>在bridge模式下，docker通过Iptable来实现容器对外是不可见。docker是如何实现的？</li>
</ol>
<p>通过宿主机的 iptables 的 <strong>SNAT</strong> 转换。<br>查看包含bridge模式容器的宿主机上的 iptables 规则，可以看到这么一条规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span><br></pre></td></tr></table></figure>

<p>这条规则会将源地址为 172.17.0.0&#x2F;16 的包（也就是从 Docker 容器产生的包），并且不是从 docker0 网卡发出的，进行源地址转换，转换成主机网卡的地址。<br>举例说明：假设主机有一块网卡为 eth0，IP 地址为 10.10.101.105&#x2F;24，网关为 10.10.101.254。从主机上一个 IP 为 172.17.0.1&#x2F;16 的容器中 ping 百度（180.76.3.151）。IP 包首先从容器发往自己的默认网关 docker0，包到达 docker0 后，也就到达了主机上。然后会查询主机的路由表，发现包应该从主机的 eth0 发往主机的网关 10.10.105.254&#x2F;24。接着包会转发给 eth0，并从 eth0 发出去（主机的 ip_forward 转发应该已经打开）。这时候，上面的 Iptable 规则就会起作用，对包做 SNAT 转换，将源地址换为 eth0 的地址。这样在外界看来，这个包就是从 10.10.101.105 上发出来的</p>
<ol start="3">
<li>docker如何实现端口映射？</li>
</ol>
<p>通过宿主机的 iptables 的 <strong>DNAT</strong> 转换。<br>在进行端口映射之后，查看宿主机的 iptables 规则的变化，发现多了这样一条规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A DOCKER ! -i docker0 -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.17.0.5:80</span><br></pre></td></tr></table></figure>
<p>此条规则就是对主机 eth0 收到的目的端口为 80 的 tcp 流量进行 DNAT 转换，将流量发往 172.17.0.5:80，也就是我们上面创建的 Docker 容器。所以，外界只需访问 10.10.101.105:80 就可以访问到容器中得服务。</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol>
<li>容器如何连接和使用宿主机上的服务？</li>
</ol>
<p>从上面的内容可以看出，如果可以的话，使用 <code>Host</code> 网络模式，是最方便的，容器里随便怎么连宿主机都毫无成本。<br>其实，即使是 <code>bridge</code> 模式，容器本来也是连接到宿主机的，唯一的一点点障碍，仅仅是宿主机的IP可能是动态的，同时也没有天然的DNS名对应宿主机（其实在Windows、MAC环境有这样的DNS名称，有需要可以查看 host.docker.internal <a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-windows/networking/#i-cannot-ping-my-containers">for windows</a> <a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-mac/networking/#i-cannot-ping-my-containers">for mac</a>）。<br>通过以下方式之一可以在 <code>bridge</code> 模式 找到宿主机的IP：</p>
<ul>
<li><p>如果使用默认网络，在宿主机上执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr show docker0 | grep inet</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">    inet6 fe80::42:62ff:fefa:e57c/64 scope link</span><br></pre></td></tr></table></figure>
<p>其中 <code>172.17.0.1</code> 便是默认网络在宿主机上的IP</p>
</li>
<li><p>如果使用自建网络，在宿主机上执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect &#123;你的自建网络名称&#125; | grep Gateway</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.19.0.1&quot;</span><br></pre></td></tr></table></figure>
<p>其中 <code>172.19.0.1</code> 便是默认网络在宿主机上的IP。<br>其实这种方式也适用于在默认网络情况，将网络名称改为 <code>bridge</code> 即可。</p>
</li>
<li><p>在容器中更加简单，执行 <code>ip route show</code> 或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hostip=$(ip route show | awk &#x27;/default/ &#123;print $3&#125;&#x27;)</span><br><span class="line">$ echo $hostip</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>ifconfig</code> 或 <code>ip addr</code> 获取到宿主机的eth0或外网IP，也是可以的，只是略微有一点性能损失。例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostip=`ip -4 addr show scope global dev eth0 | grep inet | awk &#x27;&#123;print \$2&#125;&#x27; | cut -d / -f 1`</span><br><span class="line">$ echo $hostip</span><br></pre></td></tr></table></figure></li>
</ul>
<p>获取到IP之后，还需注意：<br>a. 宿主机需要允许被连接，一般情况应该是可以的，如果不行需要设置 <code>iptables -A INPUT -i docker0 -j ACCEPT</code> 。<br>b. 宿主机上的服务应该监听在 0.0.0.0 或 * （即 <code>INADDR_ANY</code>），可以通过 <code>lsof -i | grep 端口号XXXX</code> 查看。</p>
<p>另外，为了在容器中更方便的连接宿主机，可以通过传入Host的方式来自行设置一个DNS名称，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ HOSTIP=`ip -4 addr show scope global dev eth0 | grep inet | awk &#x27;&#123;print \$2&#125;&#x27; | cut -d / -f 1`</span><br><span class="line">$ docker run  --add-host=docker:$&#123;HOSTIP&#125; --rm -it debian</span><br></pre></td></tr></table></figure>
<p>在 <code>docker-compose</code> 中则可以通过 <code>extra_hosts</code> 来达到同样的效果，laradock就是通过这样的方式（需要在 .env 中指定 <code>DOCKER_HOST_IP</code> 变量为宿主机IP。</p>
<ol start="2">
<li>一个承载了多个服务API的容器，每个API服务对应不同域名，如果让这些服务更加友好地相互访问？<br>  考虑多个项目共用一个laradock场景，nginx服承载了多个服务API，并对外提供统一的服务端口。而各个服务API的域名和nginx配置设计上是不同的，并存在相互依赖关系。某个服务想使用另一个服务的API时，要求使用默认的主机名域名（nginx）可能造成API路由冲突，各自nginx配置也不方便。如何做到对各个不同域名API的访问都指向同一个nginx容器？<br>  有多种办法解决这个问题，但最简单的，是通过 <code>--net-alias</code> 参数，或者是 docker-compose 的  <code>networks:网络XXX:aliases:</code>，例如在 laradock 的 <code>docker-compose.yml</code> 中有：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nginx:</span><br><span class="line">  ...</span><br><span class="line">  networks:</span><br><span class="line">    frontend:</span><br><span class="line">    backend:</span><br><span class="line">      aliases:</span><br><span class="line">        - account-system.dd01.test</span><br><span class="line">        - account-base-service.dd01.test</span><br><span class="line">        - member-notification-service.dd01.test</span><br><span class="line">        - points-core-system.dd01.test</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
这样就可以通过这里所列出的域名来访问各个服务，由nginx配置来根据域名（ <code>server_name</code>配置 ）分别对应到具体的服务项目。</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://docs.docker.com/network/">https://docs.docker.com/network/</a><br><a target="_blank" rel="noopener" href="https://success.docker.com/article/networking">https://success.docker.com/article/networking</a> (深入了解推荐)<br><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/#network-settings">https://docs.docker.com/engine/reference/run/#network-settings</a><br><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/docker-network-and-pipework-open-source-explanation-practice">https://www.infoq.cn/article/docker-network-and-pipework-open-source-explanation-practice</a><br><a target="_blank" rel="noopener" href="http://cizixs.com/2016/06/01/docker-default-network/">http://cizixs.com/2016/06/01/docker-default-network/</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container">https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container</a></p>

    </section>
</article>
        </main>

        <footer class="max-w-4xl mx-auto py-2 border-t border-solid border-gray-100 text-xs pb-5">
    <div class="sm:flex space-y-2 sm:space-y-0">
        <div class="sm:flex-initial">
            
            &copy;
            
                2018 -
            
            2022

            <span>吹雨听风.</span>
            
            <span>
                Powered by <a class="hexo-link " target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and
                <a target="_blank" rel="noopener" href="https://github.com/cmzz/hexo-theme-snow-white">Snow White</a>
                
            </span>
        </div>

        <div class="flex sm:flex-initial items-center">
            

            

               
        </div>
    </div>

    <div class="mt-2">
        <a href="https://creativecommons.org/licenses/by-nc/4.0/deed.zh" title="Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)" target="_blank" rel="noopener">Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)</a>
    </div>
</footer>

    </div>
</div>

</body>
</html>