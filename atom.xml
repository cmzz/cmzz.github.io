<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吹雨听风</title>
  
  <subtitle>热爱写代码.</subtitle>
  <link href="https://www.wewx.cn/atom.xml" rel="self"/>
  
  <link href="https://www.wewx.cn/"/>
  <updated>2022-04-29T16:54:31.982Z</updated>
  <id>https://www.wewx.cn/</id>
  
  <author>
    <name>吹雨听风</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这回是个 Java 小白</title>
    <link href="https://www.wewx.cn/2022/04/28/first-lesson-of-java.html"/>
    <id>https://www.wewx.cn/2022/04/28/first-lesson-of-java.html</id>
    <published>2022-04-28T16:40:00.000Z</published>
    <updated>2022-04-29T16:54:31.982Z</updated>
    
    <content type="html"><![CDATA[<p>Java 是个有20多年历史的编程语言，语言的生态和应用场景极其完善。尤其是在企业环境中有着非常官方的应用。</p><p>此前一直没有使用过 Java，对 java 并不是很，而现在马上需要给客户交付 Java 语言的支付 SDK，临时来报佛脚，边看边学边写SDK，过程着顺便做一些记录。</p><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><p>不过对于新手来说，首选面对的就是能排一长排的以 Java 为开头命名的名语，让人很是困惑：</p><ul><li><code>Java EE</code> Enterprise Edition。这个版本以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。</li><li><code>Java SE</code> Standard Edition。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。</li><li><code>Java ME</code> Micro Edition。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li><li><code>jre</code> 是Java的运行环境。面向Java程序的使用者，而不是开发者 。如果你仅下载并安装了JRE，那么你的系统只能运行Java程序。JRE是运行Java程序所必须环境的集合，包含JVM标准实现及Java核心类库。它包括Java虚拟机、Java平台核心类和支持文件。 它不包含开发工具(编译器、调试器等)。</li><li><code>jdk</code> JDK(Java Development Kit)又称J2SDK(Java2 Software Development Kit)，是Java开发工具包， 它提供了Java的开发环境(提供了编译器javac等工具，用于将java文件编译为class文件)和运行环境(提供了JVM和Runtime辅助包，用于解析class文件使其得到运行)。如果你下载并安装了JDK，那么你不仅可以开发Java程序，也同时拥有了运行Java程序的平台。 JDK是整个Java的核心，包括了Java运行环境(JRE)，一堆Java工具tools.jar和Java标准类库 (rt.jar)。</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1r10a12o9j20fk0b2t9r.jpg" alt="jre与jdk对比图"></p><p>除了上面的，还有一堆的令人困惑版本号：Java 1.x Java 1x。</p><blockquote><p>首先1996年发布了最初版本Java1.0，此后为Java1.1、J2SE1.2、J2SE1.3、J2SE1.4、采用 1.X的命名方式，直到 2004 年的 JavaOne 会议后版本数提升为 5.0，这一新版本为Java SE5.0，在 2006 年 Sun 公司终结了已经有 8 年历史的 J2SE、J2EE、J2ME 的命名方式启用了今天的 Java SE、Java EE、Java ME  命名方式，而此后的版本为 Java SE6、Java SE7、Java SE8、Java SE9、Java SE10、Java SE11、Java SE12、JAVA SE18</p></blockquote><blockquote><p>而JDK则在 Java1.0 到 Java9 对应每一个版本号 ：JDK1.0、JDK1.2 … JDK1.8、JDK1.9，Java10 以后JDK对应名称为：JDk10、JDK11、JDK12、JDK18</p></blockquote><p>所以</p><ul><li><code>Java 8</code> 指 Java SE 8.0 的版本</li><li><code>Java 18</code> 指 Java SE 18 的版本 </li><li><code>JDK 1.8</code> 则指 Java 8 对应的 JDK 版本</li></ul><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Java现在的最新版本是 Java 18，但在市场上最受欢迎的以及最为普遍的不是  <code>Java 8</code>，这又带来了环境与版本的问题。</p><p>但好在安装 Java 之后提供一个工具来管理当前系统上的java版本。命令是 <code>/usr/libexec/java_home</code> 。</p><p>在终端运行 <code>/usr/libexec/java_home -V</code> 可以看到系统中安装的所有版本的 Java  程序，并可以切换到对应的版本： <code>/usr/libexec/java_home -v &lt;version&gt;</code></p><p>如：<code>/usr/libexec/java_home -v 1.8</code>，可以切换到 JDK 1.8。之后可通过 <code>java -version</code> 来查看当前的版本。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>在 java 中有几个重要的环境变量需要在安装完 Java 之后进行配置：</p><ul><li><code>JAVA_HOME</code> 通常它指的是JDK的目录。如果需要JDK的话，大部分程序会默认去环境变量中取JAVA_HOME这个变量。</li><li><code>JRE_HOME</code> 同样，这也是一个约定的变量，通常指JRE目录。其实大部分Java程序不需要JDK，而是只需要其子集JRE，所以很多程序也会去取这个变量来用。</li></ul><p>在程序中，也可以通过 Java 提供的 API 来获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find <span class="type">String</span> <span class="variable">env</span> <span class="operator">=</span> System.getenv(<span class="string">&quot;PATH&quot;</span>);</span><br><span class="line">System.out.println(env);</span><br></pre></td></tr></table></figure><p>因此，我们可以将设置版本以及选设置环境变量放在 <code>~/.bash_profile</code> 或 <code>~/.zshrc</code> 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=`/usr/libexec/java_home -v 1.8.0_331`</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>##后缀<br>在 Java 程序中，有几种不同类型的文件后缀名，对应到程序的源码、编译等不同的阶段。</p><ul><li><code>.java</code> 是 Java 程序的源代码</li><li><code>.class</code> 是 .java 源代码编译的的字节码文件，真正可以被 jvm 执行</li><li><code>.jar</code> 将一组 .class 文件打包而来，本质是一个 zip 格式的压缩文件</li></ul><p>##Maven<br>Apache Maven，是一个软件（特别是Java软件）项目管理及自动构建工具，由Apache软件基金会所提供。</p><p>Maven项目使用项目对象模型（Project Object Model，POM）来配置。</p><p>项目对象模型存储在名为 pom.xml 的文件中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java 是个有20多年历史的编程语言，语言的生态和应用场景极其完善。尤其是在企业环境中有着非常官方的应用。&lt;/p&gt;
&lt;p&gt;此前一直没有使用过 Java，对 java 并不是很，而现在马上需要给客户交付 Java 语言的支付 SDK，临时来报佛脚，边看边学边写SDK，过程着</summary>
      
    
    
    
    
    <category term="Java" scheme="https://www.wewx.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从扫码枪说明书看创业</title>
    <link href="https://www.wewx.cn/2022/04/24/thoughts-from-the-barcode-scanner-manual.html"/>
    <id>https://www.wewx.cn/2022/04/24/thoughts-from-the-barcode-scanner-manual.html</id>
    <published>2022-04-24T15:00:00.000Z</published>
    <updated>2022-04-29T16:54:31.982Z</updated>
    
    <content type="html"><![CDATA[<p>聚合支付系统第一个版本上线有些日子，第一个版本主打是线上支付，所有对于扫码的支付方式一直没有支持。</p><p>最近在对接某一开源商城系统，其中一个功能便是要支持线下支付，故而买了一个扫码枪用来测试扫码功能。</p><p>购买的时考虑到只是测试使用，直接买了最为便宜的一款，价格不到50元。产品收到，拆开包装盒，接上电脑便开始使用。第二日收拾盒子时发现里面有一本厚厚的书明书。当时我的第一感觉是这扫码枪全新只有一个按钮，对接条码按下按钮就能读取，这么简单的一个产品为啥需要这么厚的说明书，莫非还要设置不成，这本说明书里都讲些啥？</p><p>好奇之下翻了翻。翻开说明书才发现是我肤浅了！没错就是这么个拿手上按一下按钮就能用的小设备，说明书上大概有20种不同的配置！涵盖识读模式、延迟、出厂设置、结束符设置、扫描模式等等。不仅这么多配置的数量没想到，而且配置的方式也是之前没有想到的：厂家也把个配置项做成了条码，扫码产品本身扫一下就能完成设置。</p><p>设置是这么的简单，使用产品本身最大也是唯一的功能扫一扫，就能轻轻松松的实现自定义设置，不可谓不是大道至简。</p><p>相信扫码枪厂家也知道，这个产品大部分的买家都知道如何使用，甚至都不会看说明书，即使专业用户需要更改默认设置的也不多，即便如此，他们还是把产品做得很有深度。</p><p>同样，做为一个创业者，我们产品在满足大部分的常境规用户，还需要学习这种精益求精的精神，潜心打磨，在细节处，在后台，也要认真的去设计和对待，以满足普通用户之外的专业用户需要，从而赢得口碑。</p><p>我所理解的”极致”，就是在自己创业的领域，做到比绝大多数同行优秀一点，专注努力，步步为营，稳扎稳打。</p><p>突发的感慨，致自已，致伙伴，加油！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;聚合支付系统第一个版本上线有些日子，第一个版本主打是线上支付，所有对于扫码的支付方式一直没有支持。&lt;/p&gt;
&lt;p&gt;最近在对接某一开源商城系统，其中一个功能便是要支持线下支付，故而买了一个扫码枪用来测试扫码功能。&lt;/p&gt;
&lt;p&gt;购买的时考虑到只是测试使用，直接买了最为便宜的一</summary>
      
    
    
    
    
    <category term="创业" scheme="https://www.wewx.cn/tags/%E5%88%9B%E4%B8%9A/"/>
    
    <category term="感想" scheme="https://www.wewx.cn/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>给博客上了一款新主题 《snow white》</title>
    <link href="https://www.wewx.cn/2022/04/16/hexo-theme-snow-white.html"/>
    <id>https://www.wewx.cn/2022/04/16/hexo-theme-snow-white.html</id>
    <published>2022-04-16T00:00:00.000Z</published>
    <updated>2022-04-29T16:54:31.982Z</updated>
    
    <content type="html"><![CDATA[<p>使用 hexo 创建博客也有好几个年头了，可已写下的文章的不多，就一直是默认的主题挂在那儿。</p><p>今年以来立志要练习写作，也就打算好好的整一下这个静态博客，第一件事自然是得整个好看的、符合我极简审美的主题。耐何在 Hexo 主题站上找了一圈，也没有找到完全合意的主题，那就自己写一个。说干就开，于是之款起名叫《snow white》的主题诞生。</p><p>这是我开发的第一款主题，虽有些不足，但也有些特点。</p><h3 id="极致的简约"><a href="#极致的简约" class="headerlink" title="极致的简约"></a>极致的简约</h3><p>整体以白色设计为主，没有边边框框、背景色之类的装饰，自然更不会有 icon 和各种图标了。</p><h3 id="使用-Tailwind-css"><a href="#使用-Tailwind-css" class="headerlink" title="使用 Tailwind css"></a>使用 Tailwind css</h3><p>主题的风格样式完全使用 <a href="https://tailwindcss.com/">Tailwind css</a> 进行定义，编译后也仅仅只有 13kb。Tailwind css　是一个功能类优先的 CSS 框架，样式能够语义化，这样整体的布局、样式都更加清晰明了，方便进行二次开发和调整。</p><h3 id="中文排版"><a href="#中文排版" class="headerlink" title="中文排版"></a>中文排版</h3><p>中文排版一直是个比较头痛的问题了，为使文章易于阅读，在本主题中直接使用 <a href="https://typo.sofi.sh/">typo css</a> 进行文章正文的排版。　</p><h3 id="文章优化"><a href="#文章优化" class="headerlink" title="文章优化"></a>文章优化</h3><p>扩展了文章元数据，增加了</p><ul><li>相关文章</li><li>外部链接，可以申明本文的转载来源</li></ul><h3 id="seo-优化"><a href="#seo-优化" class="headerlink" title="seo 优化"></a>seo 优化</h3><p>扩展了页面和文章的 seo 元数据，支持为每篇文章或每个页面设置 seo 信息</p><ul><li>seo 描述　</li><li>seo 关键词　</li><li>seo title</li></ul><h3 id="深色模式"><a href="#深色模式" class="headerlink" title="深色模式"></a>深色模式</h3><p>暂未之前，后续再说。</p><h2 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a>主题下载</h2><p>从 github 下载<a href="https://github.com/cmzz/hexo-theme-snow-white">《snow white》</a>主题</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>在制作主题的过程中，参考了以下几款优秀主题：</p><ul><li><a href="https://d2fan.com/">https://d2fan.com/</a></li><li><a href="http://niexiaotao.cn/">http://niexiaotao.cn/</a></li><li><a href="https://typo.sofi.sh/">https://typo.sofi.sh/</a></li></ul>]]></content>
    
    
    <summary type="html">snow white 是 hexo 的一款极致简约的博客主题，纯白色调设计，无任何多余元素和图标，seo 支持友好，如果喜欢简约风格可以尝试</summary>
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>不同场景下的文件服务选型</title>
    <link href="https://www.wewx.cn/2022/02/23/file-service-selection.html"/>
    <id>https://www.wewx.cn/2022/02/23/file-service-selection.html</id>
    <published>2022-02-23T15:00:00.000Z</published>
    <updated>2022-04-29T16:54:31.982Z</updated>
    
    <content type="html"><![CDATA[<p>文件服务是一个非常基础的功能，一般来说，每个系统都会有类似上传头像、上传图片、上传办公文件等等类似的图片或文件上传功能。</p><p>每个项目的这部分功能其实是相似的，要说不同，也就是上传的文件类型不同，大小的限制不一样，访问的权限控制的力度不同，如果一个公司中有多个不同的项目，就非常有必要设计一个通用的文件服务来满足所有的类似的文件上传的功能。</p><p>在设计文件服务中，有以下几个关键属性需要我们考虑：</p><ul><li>文件内容的敏感程度</li><li>文件平均大小</li><li>文件的使用方式、使用频率</li><li>文件的访问控制</li><li>文件的重要程度</li></ul><p>上面列举的文件属性都是从文件本身和使用方面考虑的，属性的不同决定着必须采取不同的方式来对待：</p><h4 id="文件内容的敏感程度"><a href="#文件内容的敏感程度" class="headerlink" title="文件内容的敏感程度"></a>文件内容的敏感程度</h4><p>什么是内容的敏感程度？敏感数据主要包括个人隐私信息、密码&#x2F;密钥、敏感图片等高价值数据。用大白话来说就是上传的这个文件，在上传者匿名的情况下，文件的内容会不会暴露上传者或其他人&#x2F;事物&#x2F;公司的敏感信息。例如，在金融或支付之类的系统中，文件中包含银行卡号码、电话号码、用户身份证号码，或是企业的合同等等，包含这类信息的文件就可以说是敏感文件。反之像是用户随手发到博客的图片，即使被人无意中看到也没关系，这就不敏感。</p><p>在我们设计文件服务服务的时候，如果需要存储敏感文件，那么就要充分的考虑文件内容的保密性。可以采取的常见措施为：</p><p><strong>敏感数据识别</strong>：接接收到用户上传的数据时，能够有相应的算法实别到该文件属于较为敏感的数据，以便在存储时加以区别对待。</p><p><strong>分块存储</strong>：即将文件切为很多个块。放在不同的地方，即使得到一块也无法还原文件内容。</p><p><strong>加密存储</strong>：在文件写入到磁盘保存之前，对文件字节进行加密。如果当年冠希哥懂点安全的话，那观众就少了一个大瓜。</p><p><strong>混淆存储</strong>：保存文件的时候，用一定的规则将文件内容打乱重排，窃取或看到的人也就看不懂了，从而起到保护文件中机密的作用</p><p><strong>同城冗余存储</strong>：在同一个城市的多个分区数据中心对文件保存多份副本。当某个可用区不可用时，仍然能够保障数据的正常访问。</p><p><strong>跨区域复制</strong>：跨越多个不同的地域数据中心之间复制数据，让重要数据一次保存到多个城市，从而实现更高的可用性。</p><h4 id="文件平均大小"><a href="#文件平均大小" class="headerlink" title="文件平均大小"></a>文件平均大小</h4><p>文件的体积决定着文件的访问和存储的效率。那是不是小文件相对于大文件是不是在读取速度、保存的写入速度等各方面都要快呢？并不是的。 </p><p>在淘宝系统中，由于商品图片、装修图片、描述图片都属于小图片，系统中就存在海量的小文件，或是在机器学习中，同样的也会用到大量的小文件。对于这些海量的小文件，如果采用常规的存储和访问方式，效率将会极其低下。反过来，大量的大文件也存在相应的问题，于是在这样的背景下，就诞生了各种不同的文件存储系统来适配不同的场景，如：小文件适用的 TFS，大文件适用的 GridFS，还有 HDFS、FastDFS 等等，这里就不做展开了。整理了一些参考，如下。</p><p><strong>小文件存储</strong>：</p><ul><li><a href="https://blog.51cto.com/u_14977574/2547854">支撑 Bilibili 的小文件存储系统</a></li></ul><p><strong>大文件存储</strong>：</p><ul><li><a href="https://support.huaweicloud.com/topic/182577-1-D">大文件存储系统</a></li></ul><h4 id="使用方式和频率"><a href="#使用方式和频率" class="headerlink" title="使用方式和频率"></a>使用方式和频率</h4><p>保存的文件的访问方式和访问频率通常由使用场景决定，在实际中，我们需要根据工作的负载和访问模式来确定最佳的存储方案。</p><p><strong>归档存储</strong>：因其价格低廉、通常为离线冷数据存储，非常适合海量、非结构化数据长时间备份。<br><strong>低频访问</strong>：低频访问存储价于标准化的存储和归档存存之间，支持数据实时访问，适用于较低访问频率（平均每月访问频率1到2次）的业务场景。</p><h4 id="文件的访问控制"><a href="#文件的访问控制" class="headerlink" title="文件的访问控制"></a>文件的访问控制</h4><p>文件是否能公开访问？能否授权给其他人访问？组织内的其他人否访问？</p><p>通常情况下，在设计文件服务时，除了默认只有资源拥有者或者被授权的用户允许访问外，还应支持用户授权他人访问或使用自己的上传的文件资源，需要考虑权限控制策略以解决向他人授予特定权限的问题。</p><h4 id="重要程度"><a href="#重要程度" class="headerlink" title="重要程度"></a>重要程度</h4><p>在现在信息化社会中，数据和文件就是最为重要的资产，如果要保存重要的文件，意味着在存储和使用的过程中需要做好充分的防丢失、防止损坏的措施。应对丢失最常见的方式就是异地、多城、多云同步备份，保持多份文案拷贝，此外文件版本控制机制也能比较好的防止文件意外损坏。</p><p>最后，现在处于一个云时代，在实际的工作实践中，我们在做文件系统的设计选型时，通常会考虑在底层使用云存储，例如各平台的对象存储服务（OSS）。那么此时在价格因素之外，还要充分的评估云产品的特性能否匹配到我们系统的使用场景和要求，系统评估后再做决策。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文件服务是一个非常基础的功能，一般来说，每个系统都会有类似上传头像、上传图片、上传办公文件等等类似的图片或文件上传功能。&lt;/p&gt;
&lt;p&gt;每个项目的这部分功能其实是相似的，要说不同，也就是上传的文件类型不同，大小的限制不一样，访问的权限控制的力度不同，如果一个公司中有多个不同</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="存储" scheme="https://www.wewx.cn/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker 网络模式不完全指南</title>
    <link href="https://www.wewx.cn/2018/10/10/docker-network-mode-not-complete-guide.html"/>
    <id>https://www.wewx.cn/2018/10/10/docker-network-mode-not-complete-guide.html</id>
    <published>2018-10-10T00:00:00.000Z</published>
    <updated>2022-04-29T16:54:31.978Z</updated>
    
    <content type="html"><![CDATA[<p>本次分享没有：</p><ul><li>Docker的背景</li><li>Docker的整体架构</li><li>Docker的核心实现技术</li><li>Docker的高级用法</li><li>Docker的使用秘笈</li></ul><p>本次分享是：<br><em>Docker使用中的…</em><br><em>一条命令的…</em><br><em>一个参数的..</em><br><em>不完全说明.</em></p><h3 id="Docker网络模式"><a href="#Docker网络模式" class="headerlink" title="Docker网络模式"></a>Docker网络模式</h3><p>一般文章中说的网络模式，其实主要是指 <code>docker run</code> 命令的 <code>--net</code> 或 <code>--network</code> 参数所支持的模式，默认包括：</p><ol><li>bridge模式（划重点，最后说）<br> 使用 <code>--network=bridge</code> 指定，默认设置可不指定</li><li>host模式<br> 使用 <code>--network=host</code> 指定</li><li>container模式<br> 使用 <code>--network=container:NAME_or_ID</code> 指定</li><li>none模式<br> 使用 <code>--network=none</code> 指定</li></ol><p>有时网络模式也会包括其他的模式，例如 <a href="https://docs.docker.com/network/macvlan/">macvlan</a>、<a href="https://docs.docker.com/network/overlay/">overlay</a> 等，这些并不仅通过上述参数指定，属于高级用法，如有需要可查阅文档。<br>这里只介绍常见的上述4种模式。</p><h4 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h4><p>容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</p><ul><li>试验<br>创建容器：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -d --network host --name my_nginx nginx</span><br></pre></td></tr></table></figure>在宿主机检查端口监听情况：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -tulpn | grep :80</span><br></pre></td></tr></table></figure></li></ul><p>通过这种模式，一些命令行工具可以很方便地通过docker来使用，避免在宿主机安装大量的依赖包，也便于随时清理。例如启动一个 tcpdump 的容器抓取主机上的网络报文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=host -v $PWD:/data corfr/tcpdump -i any -w /data/dump.pcap &quot;icmp&quot;</span><br></pre></td></tr></table></figure><h4 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h4><p>在了解了 host 模式后，这个模式也就好理解了。这个模式创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。<br>kubernetes 的 pod 可以认为就是用这个实现的（？），同一个 pod 中的容器共享一个 network namespace。</p><ul><li>试验<br>我们运行两个 nginx 容器：web1 和 web2：<br>web1 监听在 80 端口，使用默认的网络模型<br>web2 监听在 8080 端口，使用 container 网络模型共享 web1 的网络<br>先启动 web1，通过端口映射把端口绑定到主机上：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=web1 -p 80:80 nginx</span><br></pre></td></tr></table></figure>使用 curl 命令验证容器运行正常：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:80</span><br></pre></td></tr></table></figure>第二个容器和 host 模式相同，使用 –net 参数让新建的容器使用 web1 的网络：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=web2 -v $&#123;PWD&#125;/default.conf:/etc/nginx/sites-available/default -v $&#123;PWD&#125;/index.html:/var/www/html/index.html -d --net=container:web1 nginx</span><br></pre></td></tr></table></figure>其中 <code>default.conf</code> 文件就是修改了 nginx 默认配置文件的端口，把它变成 8080；<code>inedx.html</code> 可以随便修改一点，以区别于默认的内容。<br>在 web1 或 web2 容器里面可以验证 nginx 服务：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8080</span><br></pre></td></tr></table></figure>在两个容器中，可以分别通过 <code>ip addr</code> 查看网络配置，是完全一致的（命令和执行结果从略）。</li></ul><h4 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h4><p>这个模式和前两个不同。在这种模式下，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。<br>选择这种模式，一般是用户对网络有自己特殊的需求，不希望 docker 预设置太多的东西。</p><h4 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h4><p>在默认的bridge模式下，docker 会在宿主机上新创建一个网桥，可以把它想象成一个虚拟的交换机，所有的容器都是连到这台交换机上面的。docker 会从私有网络中选择一段地址来管理容器，比如 172.17.0.1&#x2F;16（这个地址根据你之前的网络情况而有所不同）。通过网桥，让容器的子网可以访问宿主机所连接的外网，并且可以通过 <strong>端口映射</strong> 来实现容器对外暴露端口提供服务（即外部可以通过宿主机、网桥访问容器上的服务）。这是最常用的网络模式，又分为以下两种情况：</p><ol><li>使用默认网络</li></ol><p>默认的网络docker将其称为 <code>bridge</code> 网络，在这种情况下，容器可以相互通信（若出于安全考虑，也可以禁止它们之间通信，方法是在 <code>DOCKER_OPTS</code> 变量中设置 <code>--icc=false</code>，这样只有使用 <code>--link</code> 选项才能使两个容器通信，关于 <code>--link</code> 后面还会说到）。<br>容器可以访问外部网络，但是Docker容器的IP、网络等对外是不可见的。即外部服务发现的访问客户端IP，是宿主机IP而不是容器IP。<br>而通过端口映射，可以让外部访问Docker容器的服务。</p><ul><li>试验<br>我们首先用下面命令创建一个含有 web 应用的容器，将容器的 80 端口映射到主机的 80 端口。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -d --name web -p 80:80 nginx</span><br></pre></td></tr></table></figure></li></ul><p>如果宿主机的IP为10.10.101.105，外界只需访问10.10.101.105:80 就可以访问到容器中的服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://10.10.101.105:80</span><br></pre></td></tr></table></figure><p>查看默认的网络</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect bridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;aeeabedfaa07ae4d06d0dad4ede4126a93e0efd9a2a5f0034551665aa2744976&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-29T03:25:10.046595598Z&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;1a30155cb661730fe5733a20ca8f692da0ce9edae1932b902399ed31e4b42cbd&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;web&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;2d2009eb67cd56b9a40bea4d43be87d45fd61994a85e27fd0546494d065cfd3b&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="2"><li>自行创建网络</li></ol><p>这种情况与使用默认网络基本类似，只是通过命令创建自有的网络和网桥来实现通信，这样就可以自己规划网络拓扑。在建立开发环境时，这是很常用的一种方式。laradock 即采用这种方式。</p><ul><li>试验<br>创建一个名为 <code>web-net</code> 的自定义网络，使用bridge网络驱动：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge web-net</span><br></pre></td></tr></table></figure></li></ul><p>查看一下已经创建的网络列表，可以看到除了docker自行创建的 <code>bridge</code> 网络，还有刚创建的 <code>web-net</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p>查看 <code>web-net</code> 网络的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect web-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;web-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;79be842fea854d32708498bb01bf67e3b4967ffe32405493be2f1c6424eb4752&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-29T06:57:23.58969899Z&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>创建两个容器，使用 <code>web-net</code> 网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -d --name web1 --network web-net nginx</span><br><span class="line">docker run --rm -d --name web2 --network web-net nginx</span><br></pre></td></tr></table></figure><p>再次查看 <code>web-net</code> 网络的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect web-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;web-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;79be842fea854d32708498bb01bf67e3b4967ffe32405493be2f1c6424eb4752&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-29T06:57:23.58969899Z&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;614b91e2000356945a1aba29cfa4dacad04f0bf254972c78a54aacd3663079ca&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;web1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;d0254e60f67f6d5eb155731bb028c40a2b723b0ef2aacfbe641b96dd67ca5a75&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;6aa947097ca8b6189c7a057b545ff718a82b15df4212cad6ee1ce3f2031e4bb5&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;web2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;9be085bf7f3d075f4224b285d7a3c4c382b516c22698a151c1049ea9298ee567&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可见容器 <code>web1</code> 和 <code>web2</code> 已经加入了此网络，并且分配了各自的网络IP，并使用同一个网络和网关。</p><h4 id="bridge模式下默认网络和自建网络的差别"><a href="#bridge模式下默认网络和自建网络的差别" class="headerlink" title="bridge模式下默认网络和自建网络的差别"></a>bridge模式下默认网络和自建网络的差别</h4><ol><li>提供更好的网络隔离和更灵活的拓扑</li></ol><p>这一点不言而喻，只是需了解：各容器的全部端口，对当前网络（不论是默认还是自建）内的其他容器完全开放，而对宿主机和外界都不开放，除非设置端口映射。</p><ol start="2"><li>自建网络自动提供了各容器名称的DNS解析</li></ol><p>默认网络下，各容器只能通过IP访问，除非显式设置 <a href="https://docs.docker.com/network/links/">–link 选项</a><br>而在自建网络中，默认就可以在某个容器中通过容器的名称来访问其他容器。</p><ol start="3"><li><p>容器可以动态的（无需重启容器）加入自建网络或移除（通过 <code>docker network connect</code> 或 <code>docker network disconnect</code> ，而如果要加入或移除默认网络，需要重建容器。</p></li><li><p>每个自建网络拥有自己的可配置的网桥，可以进行更灵活的网桥参数配置。</p></li><li><p>在默认网络并通过 <code>--link</code> 选项连接的容器可以共享环境变量，但在自建网络中不行。</p></li></ol><h3 id="Docker实现"><a href="#Docker实现" class="headerlink" title="Docker实现"></a>Docker实现</h3><p>Docker的网络模式实际上是基于网络驱动来实现的，要了解网络驱动，需要先了解Docker的网络模型架构。<br>Docker的网络架构基于称为 <strong>容器网络模型 Container Networking Model (CNM)</strong> 的一组接口来实现：</p><p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485228_49.png" alt="图片描述"></p><p>图中以Docker Engine为界，上半部分（高层网络设施）是下半部分（驱动）的处理实例。</p><p>CNM与网络驱动的结构和关系：</p><p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485279_69.png" alt="图片描述"></p><p>另外还需了解的是：Docker 使用了 Linux 的 <a href="https://coolshell.cn/articles/17010.html">Namespaces</a> 技术来进行资源隔离，如 PID Namespace 隔离进程，Mount Namespace 隔离文件系统，Network Namespace 隔离网络等。一个 Network Namespace 提供了一份独立的网络环境，包括网卡、路由、Iptable 规则等都与其他的 Network Namespace 隔离。</p><ol><li>Host驱动<br>  在Host驱动模式下，docker 不会为容器创建单独的网络 namespace，而是共享主机的 network namespace，也就是说：容器可以直接访问主机上所有的网络信息。</li></ol><p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485300_42.png" alt="图片描述"></p><ol><li>Bridge驱动（默认网络）<br>  在Bridge驱动模式下，如果不自行建立网络（ <code>docker network create ...</code> ），会直接使用docker自建的默认网络。docker会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</li></ol><p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485329_29.png" alt="图片描述"></p><p>Docker 完成以上网络配置的过程大致是这样的：<br>在主机上创建一对虚拟网卡 veth pair 设备。veth 设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth 设备常用来连接两个网络设备。Docker 将 veth pair 设备的一端放在新创建的容器中，并命名为 eth0。另一端放在主机中，以 veth65f9 这样类似的名字命名，并将这个网络设备加入到 docker0 网桥中，可以通过 brctl show 命令查看。</p><p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485347_11.png" alt="图片描述"></p><p>从 docker0 子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的默认网关。</p><ol start="3"><li>Bridge驱动（自建网络）</li></ol><p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485354_79.png" alt="图片描述"></p><p>与默认网络的区别在于，自行创建了网桥和一个或多个子网。</p><ol start="4"><li>Overlay、MACVLAN、None从略，如需了解请查阅 <a href="https://success.docker.com/article/networking">官方文档</a></li></ol><p>一些细节说明：</p><ol><li>host&#x2F;bridge模式分别基于Host&#x2F;Bridge驱动实现，这很好理解。那么container模式呢？</li></ol><p>实际上container模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，因此可以认为是使用“别人”的驱动来实现。</p><ol start="2"><li>在bridge模式下，docker通过Iptable来实现容器对外是不可见。docker是如何实现的？</li></ol><p>通过宿主机的 iptables 的 <strong>SNAT</strong> 转换。<br>查看包含bridge模式容器的宿主机上的 iptables 规则，可以看到这么一条规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>这条规则会将源地址为 172.17.0.0&#x2F;16 的包（也就是从 Docker 容器产生的包），并且不是从 docker0 网卡发出的，进行源地址转换，转换成主机网卡的地址。<br>举例说明：假设主机有一块网卡为 eth0，IP 地址为 10.10.101.105&#x2F;24，网关为 10.10.101.254。从主机上一个 IP 为 172.17.0.1&#x2F;16 的容器中 ping 百度（180.76.3.151）。IP 包首先从容器发往自己的默认网关 docker0，包到达 docker0 后，也就到达了主机上。然后会查询主机的路由表，发现包应该从主机的 eth0 发往主机的网关 10.10.105.254&#x2F;24。接着包会转发给 eth0，并从 eth0 发出去（主机的 ip_forward 转发应该已经打开）。这时候，上面的 Iptable 规则就会起作用，对包做 SNAT 转换，将源地址换为 eth0 的地址。这样在外界看来，这个包就是从 10.10.101.105 上发出来的</p><ol start="3"><li>docker如何实现端口映射？</li></ol><p>通过宿主机的 iptables 的 <strong>DNAT</strong> 转换。<br>在进行端口映射之后，查看宿主机的 iptables 规则的变化，发现多了这样一条规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A DOCKER ! -i docker0 -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.17.0.5:80</span><br></pre></td></tr></table></figure><p>此条规则就是对主机 eth0 收到的目的端口为 80 的 tcp 流量进行 DNAT 转换，将流量发往 172.17.0.5:80，也就是我们上面创建的 Docker 容器。所以，外界只需访问 10.10.101.105:80 就可以访问到容器中得服务。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>容器如何连接和使用宿主机上的服务？</li></ol><p>从上面的内容可以看出，如果可以的话，使用 <code>Host</code> 网络模式，是最方便的，容器里随便怎么连宿主机都毫无成本。<br>其实，即使是 <code>bridge</code> 模式，容器本来也是连接到宿主机的，唯一的一点点障碍，仅仅是宿主机的IP可能是动态的，同时也没有天然的DNS名对应宿主机（其实在Windows、MAC环境有这样的DNS名称，有需要可以查看 host.docker.internal <a href="https://docs.docker.com/docker-for-windows/networking/#i-cannot-ping-my-containers">for windows</a> <a href="https://docs.docker.com/docker-for-mac/networking/#i-cannot-ping-my-containers">for mac</a>）。<br>通过以下方式之一可以在 <code>bridge</code> 模式 找到宿主机的IP：</p><ul><li><p>如果使用默认网络，在宿主机上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr show docker0 | grep inet</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">    inet6 fe80::42:62ff:fefa:e57c/64 scope link</span><br></pre></td></tr></table></figure><p>其中 <code>172.17.0.1</code> 便是默认网络在宿主机上的IP</p></li><li><p>如果使用自建网络，在宿主机上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect &#123;你的自建网络名称&#125; | grep Gateway</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.19.0.1&quot;</span><br></pre></td></tr></table></figure><p>其中 <code>172.19.0.1</code> 便是默认网络在宿主机上的IP。<br>其实这种方式也适用于在默认网络情况，将网络名称改为 <code>bridge</code> 即可。</p></li><li><p>在容器中更加简单，执行 <code>ip route show</code> 或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hostip=$(ip route show | awk &#x27;/default/ &#123;print $3&#125;&#x27;)</span><br><span class="line">$ echo $hostip</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>ifconfig</code> 或 <code>ip addr</code> 获取到宿主机的eth0或外网IP，也是可以的，只是略微有一点性能损失。例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostip=`ip -4 addr show scope global dev eth0 | grep inet | awk &#x27;&#123;print \$2&#125;&#x27; | cut -d / -f 1`</span><br><span class="line">$ echo $hostip</span><br></pre></td></tr></table></figure></li></ul><p>获取到IP之后，还需注意：<br>a. 宿主机需要允许被连接，一般情况应该是可以的，如果不行需要设置 <code>iptables -A INPUT -i docker0 -j ACCEPT</code> 。<br>b. 宿主机上的服务应该监听在 0.0.0.0 或 * （即 <code>INADDR_ANY</code>），可以通过 <code>lsof -i | grep 端口号XXXX</code> 查看。</p><p>另外，为了在容器中更方便的连接宿主机，可以通过传入Host的方式来自行设置一个DNS名称，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ HOSTIP=`ip -4 addr show scope global dev eth0 | grep inet | awk &#x27;&#123;print \$2&#125;&#x27; | cut -d / -f 1`</span><br><span class="line">$ docker run  --add-host=docker:$&#123;HOSTIP&#125; --rm -it debian</span><br></pre></td></tr></table></figure><p>在 <code>docker-compose</code> 中则可以通过 <code>extra_hosts</code> 来达到同样的效果，laradock就是通过这样的方式（需要在 .env 中指定 <code>DOCKER_HOST_IP</code> 变量为宿主机IP。</p><ol start="2"><li>一个承载了多个服务API的容器，每个API服务对应不同域名，如果让这些服务更加友好地相互访问？<br>  考虑多个项目共用一个laradock场景，nginx服承载了多个服务API，并对外提供统一的服务端口。而各个服务API的域名和nginx配置设计上是不同的，并存在相互依赖关系。某个服务想使用另一个服务的API时，要求使用默认的主机名域名（nginx）可能造成API路由冲突，各自nginx配置也不方便。如何做到对各个不同域名API的访问都指向同一个nginx容器？<br>  有多种办法解决这个问题，但最简单的，是通过 <code>--net-alias</code> 参数，或者是 docker-compose 的  <code>networks:网络XXX:aliases:</code>，例如在 laradock 的 <code>docker-compose.yml</code> 中有：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nginx:</span><br><span class="line">  ...</span><br><span class="line">  networks:</span><br><span class="line">    frontend:</span><br><span class="line">    backend:</span><br><span class="line">      aliases:</span><br><span class="line">        - account-system.dd01.test</span><br><span class="line">        - account-base-service.dd01.test</span><br><span class="line">        - member-notification-service.dd01.test</span><br><span class="line">        - points-core-system.dd01.test</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>这样就可以通过这里所列出的域名来访问各个服务，由nginx配置来根据域名（ <code>server_name</code>配置 ）分别对应到具体的服务项目。</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://docs.docker.com/network/">https://docs.docker.com/network/</a><br><a href="https://success.docker.com/article/networking">https://success.docker.com/article/networking</a> (深入了解推荐)<br><a href="https://docs.docker.com/engine/reference/run/#network-settings">https://docs.docker.com/engine/reference/run/#network-settings</a><br><a href="https://www.infoq.cn/article/docker-network-and-pipework-open-source-explanation-practice">https://www.infoq.cn/article/docker-network-and-pipework-open-source-explanation-practice</a><br><a href="http://cizixs.com/2016/06/01/docker-default-network/">http://cizixs.com/2016/06/01/docker-default-network/</a><br><a href="https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container">https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次分享没有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker的背景&lt;/li&gt;
&lt;li&gt;Docker的整体架构&lt;/li&gt;
&lt;li&gt;Docker的核心实现技术&lt;/li&gt;
&lt;li&gt;Docker的高级用法&lt;/li&gt;
&lt;li&gt;Docker的使用秘笈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次分享是：</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Docker" scheme="https://www.wewx.cn/tags/Docker/"/>
    
    <category term="HTTPS" scheme="https://www.wewx.cn/tags/HTTPS/"/>
    
    <category term="网络" scheme="https://www.wewx.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Docker 端口的 expose 与 publish</title>
    <link href="https://www.wewx.cn/2018/08/24/docker-expose-publish.html"/>
    <id>https://www.wewx.cn/2018/08/24/docker-expose-publish.html</id>
    <published>2018-08-24T02:36:48.000Z</published>
    <updated>2022-04-29T16:54:31.978Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Dockerfile</code> 里通过 <code>Expose</code> 导出一个 <code>80</code> 的端口:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><p>启动容器后,发现还是无法本机的 <code>80</code> 端口访问容器内服务。只有在启动时通过 <code>-p</code> 参数publish 端口才可以，像下面这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 demo</span><br></pre></td></tr></table></figure><p>这是为啥呢?<br>都已经在 <code>Dockerfile</code> 里面 <code>Expose</code> 为啥还不能直接访问?</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>使用下面4中不同的方法启动容器:</p><ul><li>不在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，也不通过 <code>-p</code> 参数指定</li><li>在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，但不使用 <code>-p</code> 参数</li><li>在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，也使用 <code>-p</code> 参数</li><li>只使用 <code>-p</code> 参数</li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><ul><li>第一中情况: 不能在外网访问，也不能被 link 的 container 访问</li><li>第二种情况: 不能被外网访问，但是能被 link 的 container 访问</li><li>第三种情况: 能被外网访问，也能被 link 容器访问</li><li>第四中情况: 和第三种情况一样</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>EXPOSE</code> 只是导出端口。只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。<br>在 <code>Dockerfile</code> 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>通过 <code>docker ps</code> 命令，可以看到，端口的映射关系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 &lt;code&gt;Dockerfile&lt;/code&gt; 里通过 &lt;code&gt;Expose&lt;/code&gt; 导出一个 &lt;code&gt;80&lt;/code&gt; 的端口:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Docker" scheme="https://www.wewx.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 网络之端口映射不完全探索</title>
    <link href="https://www.wewx.cn/2018/07/20/docker-network-port-mapping.html"/>
    <id>https://www.wewx.cn/2018/07/20/docker-network-port-mapping.html</id>
    <published>2018-07-20T00:00:00.000Z</published>
    <updated>2022-04-29T16:54:31.978Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章实在团队内部的分享，如下：</p><p>今天的分享不包含故事背景、docker的发展与应用…</p><p>分享源于对问题 ‘我已经在　Dockerfile 中通过 EXPOSE 指定了端口为何任然无法访问？’ 深入探索。其实今天的分享也可以视为对上一期峰哥分享的一个补充。</p><p>Docker容器的端口映射</p><blockquote><p>容器的服务端口绑定到宿主机的端口上。效果就是：外部程序通过宿主机的P端口访问，就像直接访问 Docker 容器网络内部容器提供的服务一样。</p></blockquote><p>今天的分享主要涉及到的 Docker run 命令，参数如下：</p><ul><li>-p&#x2F;-P</li><li>–expose</li></ul><h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>expose 参数有两种使用形式：</p><ul><li>在 <code>docker run</code> 命令时指定 <code>--expose</code> 参数, 如 –expose&#x3D;8080</li><li>在 Dockerfile 中，通过 <code>EXPOSE</code> 关键字</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><blockquote><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口。</p></blockquote><p><strong>注意</strong>：</p><p>仅仅是申明。并不是说你声明了这个端口，在运行容器的时候就会自动的暴露这个端口。使用时，还要依赖于容器的操作人员进一步指定网络规则。</p><p>本质上来说， <code>EXPOSE</code> 或者 <code>--expose</code> 只是为其他命令提供所需信息的元数据，或者只是告诉容器操作人员有哪些已知选择。</p><p>验证：　通过　<code>docker run nginx</code> 启动一个容器, 然后通过　｀docker inspect id&#96;　查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;HostConfig&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;PortBindings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;443/tcp&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;80/tcp&quot;</span>: null</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到端口被标示成已暴露，但是没有定义任何与主机的端口映射。</p><h4 id="p-x2F-P"><a href="#p-x2F-P" class="headerlink" title="-p&#x2F;-P"></a>-p&#x2F;-P</h4><p><code>-p</code> 与 <code>-P</code>　参数的完整形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-p, --publish list </span><br><span class="line">-P, --publish-all </span><br></pre></td></tr></table></figure><p>这两个参数都是发布端口到宿主主机。但用法上存在一点区别。</p><p><code>-p</code> 显式将一个或者一组端口从容器里绑定到宿主机上。<br><code>-P</code> 自动的将EXPOSE指令相关的每个端口映射到宿主机的端口上。</p><p>-p 参数常见的用法是: <code>-p 宿主主机端口:容器端口</code>。　如果使用　｀docker run -p 8080:80 nginx&#96; 命令启动nginx 容器，那么容器中的 80端口会绑定到主机的8080端口。</p><p>这是，我们再通过　<code>docker inspect id</code> 来查看，将会看到下面的绑定关系:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;HostConfig&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;PortBindings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;443/tcp&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;80/tcp&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;HostIp&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;HostPort&quot;</span>: <span class="string">&quot;8080&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为没有指定443端口的绑定，所以能看到仅有 80端口和宿主机存在端口映射关系。</p><p>另外，在使用-p参数是，我们可以忽略指定宿主主机端口。这是，docker会帮助我们自动的选择一个合适端口和容器端口进行绑定。这样做的好处是在启动多个容器时可以避免端口冲突。</p><p>例如上面的启动命令可以改为 <code>docker run -p 80 nginx</code>,　这时如果我们本机的80端口被占用，docker就会自动的选择一个其他端口。我们可以通过 <code>docker ps</code> 或 <code>docker inspect</code>　命令来查看端口的映射关系。</p><p>-P 参数用法: <code>docker run -P nginx</code>.<br>-P 参数须配合　Dockerfile  一起使用，　能够将 Expose 声明的端口映射到宿主主机。</p><p>此时，使用 <code>docker inspect </code>命令，可以看到 dockerfile 中申明的端口都已经绑定到了主机上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;HostConfig&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;PortBindings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;443/tcp&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;HostIp&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;HostPort&quot;</span>: <span class="string">&quot;443&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">        <span class="string">&quot;80/tcp&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;HostIp&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;HostPort&quot;</span>: <span class="string">&quot;80&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="expose-和-p-功能对比"><a href="#expose-和-p-功能对比" class="headerlink" title="-expose 和 -p 功能对比"></a>-expose 和 -p 功能对比</h4><p>我们可以通过如下的实验来更好的理解两参数之间的区别。</p><ul><li>不在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，也不通过 <code>-p</code> 参数指定</li><li>在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，但不使用 <code>-p</code> 参数</li><li>在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，也使用 <code>-p</code> 参数</li><li>在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，也使用 <code>-P</code> 参数</li><li>只使用 <code>-p</code> 参数</li></ul><p><strong>结果</strong></p><ul><li>第一中情况: 不能在外网访问，也不能被 link 的 container 访问</li><li>第二种情况: 不能被外网访问，但是能被 link 的 container 访问</li><li>第三种情况: 能被外网访问，也能被 link 容器访问iw</li><li>第四种情况: 和第三种情况一样</li><li>第五种情况: 和第三种情况一样</li></ul><h3 id="Docker-端口映射原理"><a href="#Docker-端口映射原理" class="headerlink" title="Docker 端口映射原理"></a>Docker 端口映射原理</h3><p><strong>备注：</strong> 这一块挺乱的，我也没弄得很清楚，权当抛砖引玉了。</p><p>原本我理解端口映射是这样的一个通信过程：</p><ul><li>Docker进程启动的时候，会在宿主主机创建路由，同时创建docker0网桥</li><li>容器启动的时候创建 vethxx　的网卡，同时链接到网桥</li><li>通过 -p 参数指定端口映射后，　创建iptables规则</li><li>当有流量通过宿主主机端口进来用，通过iptables 匹配到规则后，转换为容器对应的子网ip</li><li>主机的路由指定了 172.xx　网段的ip由 docker0 处理</li><li>docker0再将请求转发到子网中容器</li></ul><p>后面和朋友了解了，发现还有　docker-proxy 的存在，于是，上面的理解是其实就片面的，不完善的。</p><hr><p>到现在，关于 Docker 端口映射的实现一共有2方案.</p><ul><li>1.7版本之前 docker-proxy + iptables DNAT 的方式<br>即，内网访问通过 iptables<br>外网访问通过 proxy</li><li>1.7版本之后的 iptables DNAT<br>完全由　iptables 实现</li></ul><p>Docker 1.7版本起，Docker提供了一个配置项： -userland-proxy，以让　Docker　用户决定是否启用　docker-proxy，默认为true，即启用docker-proxy。<br>现在的　Docker　环境默认的是： -userland-proxy&#x3D;true。iptables　和　docker-proxy　都会起作用。</p><p><strong>-userland-proxy&#x3D;true的情况下</strong></p><p>在启用 docker-proxy 的情况下。每设置一对端口映射就会启动一个 docker-proxy 进程。</p><p>可以通过 ps 命令查看 docker-proxy　进程信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep docker-proxy</span><br><span class="line"></span><br><span class="line">root      5532 19713  0 2月20 ?       00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 443 -container-ip 172.19.0.8 -container-port 443</span><br><span class="line">root      5546 19713  0 2月20 ?       00:00:01 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 80 -container-ip 172.19.0.8 -container-port 80</span><br></pre></td></tr></table></figure><p>通过 sudo netstat -nltpu 查看本机的端口监听情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      5546/docker-proxy          </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      5532/docker-proxy</span><br></pre></td></tr></table></figure><p>通过上面的命令，会发现，我们映射到宿主机的端口被　docker-proxy　进程监听了。</p><p>别急，我们再看一下iptables，发现其中增加了对应的规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"> sudo iptables-save -t nat                 </span><br><span class="line"># Generated by iptables-save v1.6.1 on Fri Feb 22 15:06:17 2019</span><br><span class="line">*nat</span><br><span class="line">:PREROUTING ACCEPT [55751:14743102]</span><br><span class="line">:INPUT ACCEPT [55615:14734886]</span><br><span class="line">:OUTPUT ACCEPT [260072:22717364]</span><br><span class="line">:POSTROUTING ACCEPT [260200:22725044]</span><br><span class="line">:DOCKER - [0:0]</span><br><span class="line">-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER</span><br><span class="line">-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER</span><br><span class="line">-A POSTROUTING -s 172.20.0.0/16 ! -o br-bf4c59b26d33 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.0/16 ! -o br-e2ab1d51063d -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.18.0.0/16 ! -o br-c9af812dc067 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.2/32 -d 172.19.0.2/32 -p tcp -m tcp --dport 6379 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.3/32 -d 172.19.0.3/32 -p tcp -m tcp --dport 27017 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.5/32 -d 172.19.0.5/32 -p tcp -m tcp --dport 3306 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.6/32 -d 172.19.0.6/32 -p tcp -m tcp --dport 9501 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.6/32 -d 172.19.0.6/32 -p tcp sudo iptables -t filter -L</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DOCKER-USER  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-1  all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain DOCKER (4 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.2           tcp dpt:6379</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.3           tcp dpt:27017</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.5           tcp dpt:mysql</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.6           tcp dpt:9501</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.6           tcp dpt:ssh</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.8           tcp dpt:https</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.8           tcp dpt:http</span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-1 (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">RETURN     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-2 (4 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">RETURN     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain DOCKER-USER (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">RETURN     all  --  anywhere             anywhere -m tcp --dport 22 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.8/32 -d 172.19.0.8/32 -p tcp -m tcp --dport 443 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.8/32 -d 172.19.0.8/32 -p tcp -m tcp --dport 80 -j MASQUERADE</span><br><span class="line">-A DOCKER -i br-bf4c59b26d33 -j RETURN</span><br><span class="line">-A DOCKER -i br-e2ab1d51063d -j RETURN</span><br><span class="line">-A DOCKER -i br-c9af812dc067 -j RETURN</span><br><span class="line">-A DOCKER -i docker0 -j RETURN</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 6379 -j DNAT --to-destination 172.19.0.2:6379</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 27017 -j DNAT --to-destination 172.19.0.3:27017</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 3306 -j DNAT --to-destination 172.19.0.5:3306</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 9501 -j DNAT --to-destination 172.19.0.6:9501</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 2222 -j DNAT --to-destination 172.19.0.6:22</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 443 -j DNAT --to-destination 172.19.0.8:443</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.19.0.8:80</span><br></pre></td></tr></table></figure><p>这里的 <code>DOCKER</code> 对应的是由 docker　自定义的一组过滤规则，可以通过　<code>sudo iptables -t filter -L</code>　查看到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t filter -L</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DOCKER-USER  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-1  all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain DOCKER (4 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.2           tcp dpt:6379</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.3           tcp dpt:27017</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.5           tcp dpt:mysql</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.6           tcp dpt:9501</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.6           tcp dpt:ssh</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.8           tcp dpt:https</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.8           tcp dpt:http</span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-1 (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">RETURN     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-2 (4 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">RETURN     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain DOCKER-USER (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">RETURN     all  --  anywhere             anywhere </span><br></pre></td></tr></table></figure><p><strong>-userland-proxy&#x3D;false的情况下</strong></p><p>待研究~</p><p><strong>性能</strong></p><p>docker-proxy 在网络上吐槽的比较多，因为每一对端口映射都会对一个 docker-proxy进程，如果端口较多，可能就会带来性能问题。且在单个 docker-proxy 的情况下，性能比 iptables 略差。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>－ –link 能够访问　expose 声明的端口</p><ul><li>-expose 仅声明端口，并不会自动映射到宿主主机</li><li>-p 指定端口映射关系</li><li>-P 将 expose 声明的端口发布到宿主主机</li><li>在处理端口映射是，iptables　规则优先，如果没有匹配到iptables规则，则由 docker-proxy处理</li></ul><p><strong>待深入研究的问题：</strong></p><ul><li>container &lt;-&gt; container、host &lt;-&gt; container、 container &lt;-&gt; host　各自怎么选择策略的</li><li>iptables 规则</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章实在团队内部的分享，如下：&lt;/p&gt;
&lt;p&gt;今天的分享不包含故事背景、docker的发展与应用…&lt;/p&gt;
&lt;p&gt;分享源于对问题 ‘我已经在　Dockerfile 中通过 EXPOSE 指定了端口为何任然无法访问？’ 深入探索。其实今天的分享也可以视为对上一期峰哥分享的</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Docker" scheme="https://www.wewx.cn/tags/Docker/"/>
    
    <category term="容器" scheme="https://www.wewx.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>PHP 的编码规范</title>
    <link href="https://www.wewx.cn/2018/07/18/php-standard.html"/>
    <id>https://www.wewx.cn/2018/07/18/php-standard.html</id>
    <published>2018-07-18T02:36:48.000Z</published>
    <updated>2022-04-29T16:54:31.982Z</updated>
    
    <content type="html"><![CDATA[<p>版本：v1.0<br>日期：2018-10-10</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>为了更好的提高技术部的工作效率，保证开发的有效性和合理性，并可最大程度的提高程序代码的可读性和可重复利用性，指定此规范。</p><h3 id="整体要求"><a href="#整体要求" class="headerlink" title="整体要求"></a>整体要求</h3><p>本规范以 <a href="https://www.php-fig.org/psr/psr-2/">PSR2</a> 规范为基础制定,是 <a href="https://www.php-fig.org/psr/psr-2/">PSR2</a> 规范的继承与扩展。</p><p>新项目需完全遵守本规范，之前旧系统代码可以可以继续遵守原有的规范。</p><h3 id="「能愿动词」的使用"><a href="#「能愿动词」的使用" class="headerlink" title="「能愿动词」的使用"></a>「能愿动词」的使用</h3><p>为了避免歧义，文档大量使用了「能愿动词」(<a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>)，对应的解释如下：</p><ul><li>必须 (MUST)：绝对，严格遵循，请照做，无条件遵守；</li><li>一定不可 (MUST NOT)：禁令，严令禁止；</li><li>应该 (SHOULD) ：强烈建议这样做，但是不强求；</li><li>不该 (SHOULD NOT)：强烈不建议这样做，但是不强求；</li></ul><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="1-关于-PHP-版本选择"><a href="#1-关于-PHP-版本选择" class="headerlink" title="1. 关于 PHP 版本选择"></a>1. 关于 PHP 版本选择</h3><ul><li><strong>必须</strong> 使用 <code>PHP 7.0</code> 以上的版本。</li><li><strong>应该</strong> 使用最新的稳定版本。</li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>源文件 <strong>必须</strong> 只使用 <code>&lt;?php</code>。</li><li>源文件中 PHP 代码的编码格式 <strong>必须</strong> 只使用 <code>不带 BOM 的 UTF-8</code>。</li><li>源文件在文件结尾处 <strong>必须</strong> 忽略掉 <code>?&gt;</code> 且 <strong>必须</strong> 以一个空行结尾。</li><li>类定义文件 <strong>必须</strong> 使用类名作为文件名, 用首字母大写。</li><li>类文件 <strong>必须</strong> 使用命名空间为路径存储。</li><li>除类文件外，其他文件全部用小写字母加下划线命名。</li></ul><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ul><li>源文件中 <strong>必须</strong> 声明为严格模式 <code>declare(strict_types=1);</code>。</li><li><strong>必须</strong> 为类方法和函数声明参数类类型、返回值类型。</li><li>一个类方法和函数 <strong>必须</strong> 只有一种类型的返回参数。</li></ul><h3 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h3><ul><li>一个源文件 <strong>应该</strong> 只用来做声明（类，函数，常量等）或者只用来做一些辅助作用的操作（例如：输出信息，修改 .ini 配置等），但不应当同时做这两件事。</li><li>类名 <strong>必须</strong> 使用 <code>StudlyCaps</code> 写法,比如 <code>SampleController</code>。</li><li>类中的常量 <strong>必须</strong> 只由大写字母和下划线(_)组成。</li><li>方法名 <strong>必须</strong> 使用 <code>camelCase（驼峰式)</code> 写法，比如 <code>getTotalById</code>。</li><li>变量名 <strong>必须</strong> 使用 <code>camelCase（驼峰式)</code> 写法。</li><li>代码 <strong>必须</strong> 使用 4 个空格符进行缩进。<br>  备注: 使用空格而不是 <code>tab</code> 键 缩进的好处在于，避免在比较代码差异、打补丁、重阅代码以及注释时产生混淆。并且，使用空格缩进，让对齐变得更方便。</li><li>关键字 以及 <code>true</code> &#x2F; <code>false</code> &#x2F; <code>null</code><br>  PHP 所有关键字 <strong>必须</strong> 全部小写。<br>  常量 <code>true</code> 、<code>false</code> 和 <code>null</code> 也必须全部小写。</li><li>运算符(<code>=, +, -, *, /, %, +=</code>等等)左右两边 <strong>必须要有</strong> 一个空格。</li><li><strong>应该</strong> 使用 <code>===</code> 运算符代替 <code>==</code> 运算符，应该使用 <code>true</code> &#x2F; <code>false</code> 常来代替 <code>1</code> &#x2F; <code>0</code>。</li><li>每行 <strong>一定不可</strong> 有多条语句。</li><li>非空行后 <strong>一定不可</strong> 有多余的空格。</li><li>运算表达式可以在运算符处换行，且运算符应 <strong>该放</strong> 在下一行的开始。</li><li>缩写词（含专有名词）与其他词组合命名， <strong>必须</strong> 使用 <code>camelCase（驼峰式)</code> 写法，如： <code>ApiUrl</code>。</li></ul><h3 id="行-与-空行"><a href="#行-与-空行" class="headerlink" title="行 与 空行"></a>行 与 空行</h3><ul><li>每行的字符数 <strong>应该</strong> 保持在 80 个以内， 通常情况 <strong>不该</strong> 超过 120 个。如果换行可能破坏语意或降低可阅读性，可作为例外超出限制。</li><li>代码块开始之前与结束符 <code>&#125;</code> 之后，<strong>应该</strong> 有一个空行。</li><li>方法和函数的 <code>return</code> 语句之前，<strong>应该</strong> 有一个空行。</li><li>完成一定功能的代码块前后，<strong>应该</strong> 各有一个空行。</li><li><strong>一定不可</strong> 存在连续的 2 个以上的空行。</li></ul><h3 id="类、Interface、Trait"><a href="#类、Interface、Trait" class="headerlink" title="类、Interface、Trait"></a>类、Interface、Trait</h3><ul><li><p>每个 <code>namespace</code> 命名空间声明语句和 <code>use</code> 声明语句块后面，必须插入一个空白行。所有 <code>use</code> <strong>必须</strong> 在 <code>namespace</code> 后声明。每条 <code>use</code> 声明语句 <strong>必须</strong> 只有一个 <code>use</code> 关键词。<code>use</code> 声明语句块后 <strong>必须</strong> 要有一个空白行。例如：</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">FooClass</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">BarClass</span> <span class="keyword">as</span> <span class="title">Bar</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OtherVendor</span>\<span class="title">OtherPackage</span>\<span class="title">BazClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... additional PHP code ...</span></span><br></pre></td></tr></table></figure></li><li><p>扩展与继承，关键词 <code>extends</code> 和 <code>implements</code>  <strong>必须</strong> 写在类名称的同一行，类的开始花括号 <strong>必须</strong> 独占一行，结束花括号也 <strong>必须</strong> 在类主体后独占一行。例如:</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">FooClass</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">BarClass</span> <span class="keyword">as</span> <span class="title">Bar</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OtherVendor</span>\<span class="title">OtherPackage</span>\<span class="title">BazClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> <span class="keyword">implements</span> <span class="title">ArrayAccess</span>, <span class="title">Countable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// constants, properties, methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>implements</code> 的继承列表也可以分成多行，这样的话，每个继承接口名称都 <strong>必须</strong> 分开独立成行，包括第一个。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">FooClass</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">BarClass</span> <span class="keyword">as</span> <span class="title">Bar</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OtherVendor</span>\<span class="title">OtherPackage</span>\<span class="title">BazClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">ArrayAccess</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Countable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// constants, properties, methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的开始花括号(<code>&#123;</code>) <strong>必须</strong> 写在函数声明后自成一行，结束花括号(<code>&#125;</code>)也 <strong>必须</strong> 写在函数主体后自成一行。</p></li><li><p>方法的开始花括号(<code>&#123;</code>) <strong>必须</strong> 写在函数声明后自成一行，结束花括号(<code>&#125;</code>) <strong>也必须</strong> 写在函数主体后自成一行。<br>  一个标准的方法声明可参照以下范例，留意其括号、逗号、空格以及花括号的位置。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fooBarBaz</span>(<span class="params"><span class="variable">$arg1</span>, &amp;<span class="variable">$arg2</span>, <span class="variable">$arg3</span> = []</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的属性和方法必须添加访问修饰符（<code>private</code>、<code>protected</code> 以及 <code>public</code>）， <code>abstract</code> 以及 <code>final</code> 必须声明在访问修饰符之前，而 <code>static</code> <strong>必须</strong> 声明在访问修饰符之后。<br>  以下是属性声明的一个范例：</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$foo</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  需要添加 <code>abstract</code> 或 <code>final</code> 声明时， <strong>必须</strong> 写在访问修饰符前，而 <code>static</code> 则 <strong>必须</strong> 写在其后。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">static</span> <span class="variable">$foo</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">zim</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的属性和方法 <strong>一定不可</strong> 使用 <code>_</code> 开头命名来区分私有方法。</p></li><li><p>方法的参数声明过多时，每个参数可以独占一行</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReturnTypeVariations</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">anotherFunction</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">string</span> <span class="variable">$foo</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">string</span> <span class="variable">$bar</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> <span class="variable">$baz</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类方法与函数"><a href="#类方法与函数" class="headerlink" title="类方法与函数"></a>类方法与函数</h3><ul><li><p>参数和变量列表中逗号(，)前 <strong>必须不能有</strong> 空格，而逗号后 <strong>必须要有</strong> 空格。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"><span class="variable">$arg1</span>, &amp;<span class="variable">$arg2</span>, <span class="variable">$arg3</span> = []</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参数列表可以分列成多行，这样，包括第一个参数在内的每个参数都 <strong>必须</strong> 单独成行。<br>  拆分成多行的参数列表后，结束括号以及方法开始花括号 <strong>必须</strong> 写在同一行，中间用一个空格分隔。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">aVeryLongMethodName</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        ClassTypeHint <span class="variable">$arg1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        &amp;<span class="variable">$arg2</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">array</span> <span class="variable">$arg3</span> = []</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法及函数调用时，方法名或函数名与参数左括号之间 <strong>一定不可</strong> 有空格，参数右括号前也 <strong>一定不可</strong> 有空格。每个参数前 <strong>一定不可</strong> 有空格，但参数 <code>，</code> 之后 <strong>必须</strong> 有一个空格。</p></li></ul><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><ul><li><p>控制结构的基本规范如下</p><ul><li>控制结构的关键字后 <strong>必须</strong> 要有一个空格符，而调用方法或函数时则一定不能有。</li><li>控制结构的开始花括号(<code>&#123;</code>) <strong>必须</strong> 写在声明的同一行，而结束花括号(<code>&#125;</code>)必须写在主体后自成一行。</li><li>控制结构的开始左括号后和结束右括号前，都 <strong>一定不可</strong> 有空格符。</li></ul></li><li><p><code>case</code> 语句 <strong>必须</strong> 相对 <code>switch</code> 进行一次缩进，而 <code>break</code> 语句以及 <code>case</code> 内的其它语句都 <strong>必须</strong> 相对 <code>case</code> 进行一次缩进。<br>如果存在非空的 <code>case</code> 直穿语句，主体里 <strong>必须</strong> 有类似 <code>// no break</code> 的注释。例如:</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="variable">$expr</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;First case, with a break&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Second case, which falls through&#x27;</span>;</span><br><span class="line">        <span class="comment">// no break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Third case, return instead of break&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Default case&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>应该</strong> 使用关键词 <code>elseif</code> 代替所有 <code>else if</code>，以使得所有的控制关键字都像是单独的一个词。例如:</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$expr1</span>) &#123;</span><br><span class="line">    <span class="comment">// if body</span></span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="variable">$expr2</span>) &#123;</span><br><span class="line">    <span class="comment">// elseif body</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// else body;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>while 和 do while。一个规范的 while 语句 <strong>应该</strong> 如下所示，注意其 括号、空格以及花括号的位置。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$expr</span>) &#123;</span><br><span class="line">    <span class="comment">// structure body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>标准的 <code>do while</code> 语句如下所示，同样的，注意其 括号、空格以及花括号的位置。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// structure body;</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="variable">$expr</span>);</span><br></pre></td></tr></table></figure></li><li><p>标准的 <code>for</code> 语句如下所示，注意其括号、空格以及花括号的位置。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">10</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="comment">// for body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>标准的 <code>foreach</code> 语句如下所示，注意其括号、空格以及花括号的位置。例如:</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$iterable</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="comment">// foreach body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>标准的 <code>try catch</code> 语句如下所示，注意其括号、空格以及花括号的位置。例如:</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// try body</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FirstExceptionType <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="comment">// catch body</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (OtherExceptionType <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="comment">// catch body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li><p>闭包声明时，关键词 <code>function</code> 后以及关键词 <code>use</code> 的前后都必须要有一个空格。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$closureWithArgs</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$arg1</span>, <span class="variable">$arg2</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$closureWithArgsAndVars</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$arg1</span>, <span class="variable">$arg2</span></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$var1</span>, <span class="variable">$var2</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$closureWithArgsVarsAndReturn</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$arg1</span>, <span class="variable">$arg2</span></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$var1</span>, <span class="variable">$var2</span></span>): <span class="title">bool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$longArgs_longVars</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="variable">$longArgument</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="variable">$longerArgument</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="variable">$muchLongerArgument</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) <span class="keyword">use</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="variable">$longVar1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="variable">$longerVar2</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="variable">$muchLongerVar3</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$foo</span>-&gt;<span class="title function_ invoke__">bar</span>(</span><br><span class="line">    <span class="variable">$arg1</span>,</span><br><span class="line">    function (<span class="variable">$arg2</span>) <span class="keyword">use</span> ($<span class="title">var1</span>) &#123;</span><br><span class="line">        // <span class="title">body</span></span><br><span class="line">    &#125;,</span><br><span class="line">    $<span class="title">arg3</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>开始花括号 <strong>必须</strong> 写在声明的同一行，结束花括号 <strong>必须</strong> 紧跟主体结束的下一行。</p></li><li><p>同事遵守 <code>函数</code> 和 <code>类方法</code> 的相关原则。</p></li></ul><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><ul><li><p>匿名类 <strong>必须</strong> 遵守 <code>闭包</code> 和 <code>类</code> 的相关原则。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$instance</span> = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> \<span class="title">Foo</span> <span class="keyword">implements</span> \<span class="title">HandleableInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Class content</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$instance</span> = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> \<span class="title">Foo</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    \<span class="title">ArrayAccess</span>,</span></span><br><span class="line"><span class="class">    \<span class="title">Countable</span>,</span></span><br><span class="line"><span class="class">    \<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Class content</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><p>文件头部注释 (可选)</p><ul><li><code>author</code>： 作者以及联系邮箱。</li><li><code>createTime</code>：文件创建时间 - 可以通过git来追踪。</li><li><code>description</code>：当前文件的详细介绍。</li></ul>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* createTime : 18-10-8 12:23</span></span><br><span class="line"><span class="comment">* description: 测试通知服务</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>方法注释 (可选)<br>  使用 <code>PHPdoc</code> 方式，描述方法功能、参数等。</p><ul><li><code>@param</code> 参数，语法：<code>@param [&quot;Type&quot;] [name] [&lt;description&gt;]</code>，标签用于记录函数或方法的单个参数，且可以有多行描述，不需要明确的分隔。</li><li><code>@return</code> 返回，语法：<code>@return &lt;&quot;Type&quot;&gt; [description]</code>，标签用于记录函数或方法的返回类型，同样支持多行描述。</li><li><code>@throws</code> 参数，语法：<code>@throws [Type] [&lt;description&gt;]</code>，标签用于记录函数或方法的抛出的错误异常，注明发生情况。</li></ul>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建商户 union_id</span></span><br><span class="line"><span class="comment"> * - 向 points_account 插入一条数据，获取 id</span></span><br><span class="line"><span class="comment"> * - 使用该 id 向 account base service 申请 union_id</span></span><br><span class="line"><span class="comment"> * - 更新记录</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $roleType 角色类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> PointsAccount 账号 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> \Throwable 生成 union_id 或者 创建账号失败抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">generateUnionIdAndCreateAccount</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$roleType</span></span>): <span class="title">PointsAccount</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变量注释 (可选)</p><ul><li><code>@var</code> 变量，语法：<code>@var [&quot;Type&quot;] [element_name] [&lt;description&gt;]</code>，标签用于记录变量类型，也用于记录常量等</li></ul>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> integer 待审核</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">STATUS_PENDING</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Vendor</span>\<span class="title">Package</span>\&#123;<span class="title">ClassA</span> <span class="keyword">as</span> <span class="title">A</span>, <span class="title">ClassB</span>, <span class="title">ClassC</span> <span class="keyword">as</span> <span class="title">C</span>&#125;;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Vendor</span>\<span class="title">Package</span>\<span class="title">SomeNamespace</span>\<span class="title">ClassD</span> <span class="keyword">as</span> <span class="title">D</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">function</span> <span class="title">Vendor</span>\<span class="title">Package</span>\&#123;<span class="title">functionA</span>, <span class="title">functionB</span>, <span class="title">functionC</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">const</span> <span class="title">Vendor</span>\<span class="title">Package</span>\&#123;<span class="title">ConstantA</span>, <span class="title">ConstantB</span>, <span class="title">ConstantC</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Bar</span> <span class="keyword">implements</span> <span class="title">FooInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sampleFunction</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$a</span>, <span class="keyword">int</span> <span class="variable">$b</span> = <span class="literal">null</span></span>): <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$a</span> === <span class="variable">$b</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">bar</span>();</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="variable">$a</span> &gt; <span class="variable">$b</span>) &#123;</span><br><span class="line">            <span class="variable">$foo</span>-&gt;<span class="title function_ invoke__">bar</span>(<span class="variable">$arg1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title class_">BazClass</span>::<span class="title function_ invoke__">bar</span>(<span class="variable">$arg2</span>, <span class="variable">$arg3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;版本：v1.0&lt;br&gt;日期：2018-10-10&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于 MySQL InnoDB 引擎的索引知识</title>
    <link href="https://www.wewx.cn/2018/06/01/indexing-knowledge-about-the-mysql-innodb-engine.html"/>
    <id>https://www.wewx.cn/2018/06/01/indexing-knowledge-about-the-mysql-innodb-engine.html</id>
    <published>2018-06-01T00:00:00.000Z</published>
    <updated>2022-04-29T16:54:31.982Z</updated>
    
    <content type="html"><![CDATA[<p>这边文章在草稿箱放了整整１年半啊.</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>从 MySQL 5.5.5 版本开始 InnoDB 是 Mysql 的默认存储引擎。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="支持的索引"><a href="#支持的索引" class="headerlink" title="支持的索引"></a>支持的索引</h3><ul><li>支持全文索引</li><li>支持 B+ 树索引</li><li>支持 hash 索引</li></ul><p>其中 hash 索引是完全自动的，不能人工干预，InnoDB 引擎会监控表上各个索引页的查询，如果观察到建立 hash 索引可以带来速度提升，则自动建立 hash 索引</p><p><strong>B+ 树索引</strong><br>就是我们所说的索引。<br>B+ 树索引不能直接找到具体数据的行，只能找到数据所在的页，数据库通过把也度入到内存，在内存中查找，最后得到数据。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>二叉树：每个节点有两个子节点，数据量的增大必然导致高度的快速增加。<br>搜索二叉树：左子树小于根，右子树大于根。<br>平衡二叉树：2 棵子树的高度差为 1（查找效率共，但维护成本也高）。<br>B树：是一种自平衡的树。概括来说是一个一般化的二叉查找树，可以拥有多于 2 个子节点（也是 MyISAM  参考的数据结构，ISAM：索引顺序存取方法）。</p><p>B+ 树： 通过二叉查找树，再由平衡二叉树，B 树演化来的。因此，B+ 树也是一种平衡树。</p><p><img src="https://ws1.sinaimg.cn/large/006CUA5Vgy1fzme91elfej30m80a8q4h.jpg"></p><p>⤴️ 高度为2 每页可存放3条记录的B+树。</p><p>B+ 树元素自底向上插入。所有记录节点都是按键值的大小顺序存放在同一层叶子节点上，由各叶子节点指针进行连接。</p><h4 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+ 树的插入操作"></a>B+ 树的插入操作</h4><p>节点未满：直接插入。</p><p>节点已满：这时候需要分裂。当一个结点满时，分配一个新的结点，并将原结点中 1&#x2F;2 的数据复制到新结点，最后在父结点中增加新结点的指针；B+ 树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟节点的指针</p><h4 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+ 树的删除操作"></a>B+ 树的删除操作</h4><p>直接删除：如果不是 Page Index 节点，则直接删除。<br>删除 Page Index 节点： 直接删除，使用右边的节点作为 Page Index， 同事更新父节点。<br>合并：删除后，节点数量小于 50%，则和兄弟节点合并。同时更新父节点。</p><h4 id="B-树的查找"><a href="#B-树的查找" class="headerlink" title="B+ 树的查找"></a>B+ 树的查找</h4><p><img src="https://ws1.sinaimg.cn/large/006CUA5Vgy1fzmearrmt8j30fi04vwet.jpg" alt="B+ 树的查找示意图"></p><p>通常向下读取一个节点的动作可能会是一次磁盘IO操作，不过非叶节点通常会在初始阶段载入内存以加快访问速度。同时为提高在节点间横向遍历速度，真实数据库中可能会将图中蓝色的CPU计算&#x2F;内存读取优化成二叉搜索树。</p><h3 id="InnoDB-的索引"><a href="#InnoDB-的索引" class="headerlink" title="InnoDB 的索引"></a>InnoDB 的索引</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>InnoDB使用的是聚集索引，就是按照每张表的主键构建一颗B+树，叶子节点中存放的整张表的行记录数据（数据页）。各数据页之间使用双向链表连接。</p><p>聚集索引即是主键。<br>每张表只能有用一个聚集索引。<br>数据在逻辑上是顺序的，物理上不是顺序存储的。<br>聚集索引的排序、查找、范围查找非常快。</p><h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>也称非聚集索引。叶子节点不包含行记录的全部数据。叶子节点除了包含键值以外，还包含一个数钱，用来告诉引擎在哪里找到数据（指向到聚集索引）。<br>辅助索引不影响数据在聚集索引中的组织，因此，一张表可以包含多个辅助索引。</p><p>假设辅助索引树高3层，聚集索引树为3层。辅助索引 B+ 树中检索 name，需要先经过3次 IO 到达其叶子节点获取对应的主键。接着再经过3次 IO 使用主键在聚集索引 B+ 树中再执行一次 B+ 树检索操作，最终到达叶子节点即可获取整行数据。</p><p>聚簇索引的优势:</p><ul><li>行数据和叶子节点存储在一起，这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回。</li><li>保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。</li></ul><h2 id="正确建立索引"><a href="#正确建立索引" class="headerlink" title="正确建立索引"></a>正确建立索引</h2><ul><li><p>最左前缀匹配</p></li><li><p>&#x3D; 和 in 可以乱序， MySQL 的查询优化器会帮你优化成索引可以识别的形式</p></li><li><p>尽量选择区分度高的列作为索引（Cardinality 值），区分度的公式是  <code>count(distinct col)/count(*)</code> ，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1</p><ul><li><code>show index from user</code> 可查看 Cardinality 值（采样统计，非实时）</li><li><img src="https://ws1.sinaimg.cn/large/006CUA5Vgy1fzme9yvis3j31lg09mq58.jpg" alt="Cardinality 值"></li></ul></li><li><p>索引列不能参与计算</p></li><li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这边文章在草稿箱放了整整１年半啊.&lt;/p&gt;
&lt;h2 id=&quot;InnoDB&quot;&gt;&lt;a href=&quot;#InnoDB&quot; class=&quot;headerlink&quot; title=&quot;InnoDB&quot;&gt;&lt;/a&gt;InnoDB&lt;/h2&gt;&lt;p&gt;从 MySQL 5.5.5 版本开始 InnoDB 是 M</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="MySQL" scheme="https://www.wewx.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 分区表探索</title>
    <link href="https://www.wewx.cn/2017/12/08/mySQL-partitioned-table-exploration.html"/>
    <id>https://www.wewx.cn/2017/12/08/mySQL-partitioned-table-exploration.html</id>
    <published>2017-12-08T00:00:00.000Z</published>
    <updated>2022-04-29T16:54:31.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果需要定时清理一张普通大表里的历史数据。</p><p>可以使用一个或多个带 where 条件的 delete 语句去删除（where条件是时间）。 如果表数据量较大，这对数据库的造成了很大压力。即使我们把这些旧数据删除了，但是底层的数据文件并没有变小。</p><blockquote><p>为什么没有变小？<br>当删除数据 时，MYSQL 并不会立即回收表空间。被已删除数据的占据的存储空间，以及索引位会空在那里，等待新的数据来弥补这个空缺。<br>强行回收： OPTIMIZE TABLE</p></blockquote><p>面对这类问题，其实最有效的方法就是在使用分区表。分区表最大的优点就是可以非常高效的进行历史数据的清理。</p><h2 id="关于分区表"><a href="#关于分区表" class="headerlink" title="关于分区表"></a>关于分区表</h2><p>分区表不是在存储引擎层完成的。这是 MySQL 支持的功能（5.1开始）</p><p>原理：<br>将表索引分解为多个更小、更可管理的部分。</p><p>从逻辑上讲，只有一个表或者索引，但是物理上这个表或者索引可能由数十个物理分区组成。</p><p>分区表最大的优点就是可以非常高效的进行历史数据的清理。</p><p>每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理（如果分区表很大，亦可以将分区分配到不同的磁盘上去）。</p><p>在执行查询的时候，优化器会根据分区定义过滤哪些没有我们需要数据的分区，这样查询就无须全表扫描所有分区，只查找包含需要数据的分区即可。</p><h2 id="检查分区功能是否启用"><a href="#检查分区功能是否启用" class="headerlink" title="检查分区功能是否启用"></a>检查分区功能是否启用</h2><pre><code>mysql&gt; SHOW PLUGINS \G;*************************** 43. row ***************************   Name: partition Status: ACTIVE   Type: STORAGE ENGINELibrary: NULLLicense: GPL</code></pre><h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><p>MySQL目前只支持 水平分区（水平分区就是将不同的行分配到不同的物理文件中）。</p><ul><li><p>范围分区（RANGE）<br>行数据基于一个给定的连续区间的值被放入分区。</p></li><li><p>列表分区（LIST）<br>和 RANGE 分区类似，只不过面向的是离散的值。</p></li><li><p>哈希分区（HASH）<br>根据用户自定义的表达式返回的值来区分放入那个分区。</p></li><li><p>KEY分区<br>根据 MySQL 数据库提供的哈希函数来进行分区。</p></li><li><p>COLUMNS 分区<br>可以对多个列的值进行分区。（MySQL 5.5+ 开始支持）。</p></li></ul><h2 id="RANGE-分区"><a href="#RANGE-分区" class="headerlink" title="RANGE 分区"></a>RANGE 分区</h2><p>这是最常用的一种分区类型。最常见的是基于时间字段（基于分区的列最好是整型）来分区。<br>分区的列可以允许 null 值，如果分区的列值是 null，则会选择第一个分区。</p><pre><code>CREATE TABLE range_partition_test (    id INT,    pdate INT)PARTITION BY RANGE (pdate) (    PARTITION p1 VALUES LESS THAN ( 201702 ),    PARTITION p2 VALUES LESS THAN ( 201703 ),    PARTITION p3 VALUES LESS THAN ( 201704 ),    PARTITION p4 VALUES LESS THAN (MAXVALUE));</code></pre><p><code>MAXVALUE</code> 是一个无穷大的值，所以p4 分区即为默认的分区。</p><p>在执行查询的时候，带上分区字段，这样可以使用分区剪裁功能。</p><pre><code>mysql&gt; select * from range_partition_test;+------+--------+| id   | pdate  |+------+--------+|    1 | 201701 ||    2 | 201702 ||    3 | 201703 ||    4 | 201704 ||    5 | 201705 |+------+--------+mysql&gt; explain partitions select * from range_partition_test where pdate between 201702 and 201703;+----+-------------+----------------------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table                | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+----------------------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | range_partition_test | p2,p3      | ALL  | NULL          | NULL | NULL    | NULL |    2 |    50.00 | Using where |+----+-------------+----------------------+------------+------+---------------+------+---------+------+------+----------+-------------+</code></pre><p>只查询了p2,p3分区。</p><h2 id="LIST-分区"><a href="#LIST-分区" class="headerlink" title="LIST 分区"></a>LIST 分区</h2><p>LIST 分区和 RANGE 分区类似。<br>区别在于 LIST 是枚举值列表的集合，RANGE 是连续的区间值的集合。二者在语法方面非常的相似。<br>建议 LIST 分区列是非 null 列，否则插入 null 值如果枚举列表里面不存在 null 值会插入失败（和 RANGE 分区不一样）。</p><pre><code>CREATE TABLE list_partition_test (    id INT,    pdate INT)PARTITION BY LIST (pdate) (    PARTITION p1 VALUES IN (1,3,5,7,9),    PARTITION p2 VALUES IN (2,4,6,8,0));</code></pre><h2 id="Hash-分区"><a href="#Hash-分区" class="headerlink" title="Hash 分区"></a>Hash 分区</h2><p>HASH 分区的目的是讲数据均匀的分不到预先定义的各个分区中。保证各个分区的记录数量大体上都是一致的。</p><p>在实际工作中经常遇到像会员表的这种表。并没有明显可以分区的特征字段。但表数据有非常庞大。这时候可以使用 HASH 分区。</p><p>基于给定的分区个数，将数据分配到不同的分区，HASH分区只能针对整数进行 HASH。</p><pre><code>CREATE TABLE hash_partition_test (    id INT,    pdate INT)PARTITION BY HASH(id)PARTITIONS 4;</code></pre><ul><li>上面的分区对象(id)也可以是一个表达式，表达式的结果必须是整数值。</li><li>HASH 分区可以不用指定 PARTITIONS 子句，则默认分区数为1。</li><li>不允许只写 PARTITIONS，而不指定分区数。</li><li>HASH 分区的底层实现其实是基于 MOD 函数。</li></ul><h2 id="KEY-分区"><a href="#KEY-分区" class="headerlink" title="KEY 分区"></a>KEY 分区</h2><p>KEY 分区和 HASH 分区相似。不同之处在于：</p><ul><li>KEY 分区允许多列，而 HASH 分区只允许一列。</li><li>如果在有主键或者唯一键的情况下，key 中分区列可不指定，默认为主键或者唯一键，如果没有，则必须显性指定列。</li><li>KEY 分区对象必须为列，而不能是基于列的表达式。</li><li>KEY 分区和 HASH 分区的算法不一样，对于 innodb 引擎，采用的是 MD5 值来分区。</li></ul><h2 id="COLUMNS-分区"><a href="#COLUMNS-分区" class="headerlink" title="COLUMNS 分区"></a>COLUMNS 分区</h2><p>可以直接使用非整型的数据进行分区。分区根据类型直接比较而得，不需要转化为整型。同时，可以对多个列值进行分区。</p><pre><code>CREATE TABLE listvardou (    id INT,    pdate INT)PARTITION BY LIST COLUMNS(id,pdate)(    PARTITION a VALUES IN ( (1, 201701), (1, 201702), (1, 201703)),    PARTITION b VALUES IN ( (2, 201702) )    PARTITION b VALUES IN ( (3, 201703) ));</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>RANGE 分区，LIST 分区，HASH 分区，KEY 分区对象返回的只能是整数值，如果不是整型，则需要使用函数将其转化为整型。</li><li>数据表非常大以至于无法全部都放到内存，或者只在表的最后部分有热点数据，其他均为历史数据的情况下，可以选用分区表。</li><li>分区表数据更容易维护（可独立对分区进行优化、检查、修复及批量删除大数据可以采用drop分区的形式等）。</li><li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。</li><li>可以备份和恢复独立的分区，非常适用于大数据集的场景。</li><li>分区的主要目的是用于数据库的高可用性管理。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;如果需要定时清理一张普通大表里的历史数据。&lt;/p&gt;
&lt;p&gt;可以使用一个或多个带 where 条件的 delete 语句去删除（where条件</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="MySQL" scheme="https://www.wewx.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>记一次由于磁盘 Inode 用满导致的故障</title>
    <link href="https://www.wewx.cn/2017/10/01/remember-a-fault-due-to-full-disk-inode.html"/>
    <id>https://www.wewx.cn/2017/10/01/remember-a-fault-due-to-full-disk-inode.html</id>
    <published>2017-10-01T00:00:00.000Z</published>
    <updated>2022-04-29T16:54:31.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在一台ubuntu服务器上运行了多个laravel项目</p><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>昨天早上有客户提醒服务不可用。排查后发现是磁盘满了（100G）。删除掉40G的备份文件后，服务恢复正常。</p><p>但是今天早上，又有很多客户反应服务挂掉了。</p><p>查看日志，发现有大量的 failed to open stream: No space left on device 的错误。使用 df -h 查看，磁盘明明还有40G空间，按道理不应该出现这个错误。</p><h2 id="查找问题"><a href="#查找问题" class="headerlink" title="查找问题"></a>查找问题</h2><p>磁盘空间明明还有，但提示空间不足。遂使用 df -ih 查看了一下 inode 的使用情况。</p><pre><code>➜  ~ df -ihFilesystem     Inodes IUsed IFree IUse% Mounted onudev             490K   437  490K    1% /devtmpfs            494K   944  494K    1% /run/dev/vda1        2.5M  102K  2.5M    4% /tmpfs            494K     1  494K    1% /dev/shmtmpfs            494K     2  494K    1% /run/locktmpfs            494K    16  494K    1% /sys/fs/cgroup/dev/vdb1        6.3M  6.3M  1.3M. 100% /mnt/vdb</code></pre><p>发现 inode 已经用满了，从而导致系统无法创建文件。以至于系统抛出 No space left on device 错误。</p><p>inode是什么？</p><blockquote><p>理解inode，要从文件储存说起。</p></blockquote><blockquote><p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p></blockquote><blockquote><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p></blockquote><blockquote><p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p></blockquote><blockquote><p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p></blockquote><p>引用自：<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html">http://www.ruanyifeng.com/blog/2011/12/inode.html</a></p><p>因此，为题就是磁盘的 block 空间还有剩余，但是 inode 空间用完，无法继续创建新文件。</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>在运行的几个 laravel 项目中，有2个访问量很大，而且有写缓存（CACHE_DRIVER&#x3D;file)。</p><p>进入到laravel项目的 storeage&#x2F;framework&#x2F;cache&#x2F;data 目录下，发现存在大量的文件夹，里面存储的是大量的小文件（一个文件只有几KB）。</p><p>这些大量的小文件并没有占用多少 block 空间，却吧 inode 空间占满了。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ol><li><p>删除项目的 Cache 文件<br>停止 nginx、 php-fpm，进入 data 目录，执行：rm -rf .&#x2F;*<br>然后悲剧了，系统卡死， 10分钟、半小时、1小时…，没办法，只能先清理一部分出来，晚上再删。</p></li><li><p>切换缓存到 redis（阿里云的云服务）</p></li><li><p>搞一个脚本，每晚定时清理。</p></li><li><p>挂在新的磁盘，软连接到 cache 目录，以缓解单块磁盘的inode空间不足的问题。（计划实施）</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在一台ubuntu服务器上运行了多个laravel项目&lt;/p&gt;
&lt;h2 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;h</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Linux" scheme="https://www.wewx.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>https 背后的内幕</title>
    <link href="https://www.wewx.cn/2017/04/10/explor-https.html"/>
    <id>https://www.wewx.cn/2017/04/10/explor-https.html</id>
    <published>2017-04-10T00:00:00.000Z</published>
    <updated>2022-04-29T16:54:31.982Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是一篇内部分享文</p></blockquote><p><img src="https://cdn.learnku.com/uploads/images/201702/06/4949/nx3raoaCAR.png" alt="file"></p><p>背景：  2016年底 iOS App 强制要求使用HTTPS协议。Chrome 计划在2017年将所有使用非 HTTPS 协议的网站标记为不安全，并在地址栏的前面显示一个红叉。Mozilla 宣布所有的新特性将只提供给 HTTPS 网站，HTTP 网站将逐步被禁止访问浏览器功能。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP-的缺点"><a href="#HTTP-的缺点" class="headerlink" title="HTTP 的缺点"></a>HTTP 的缺点</h3><h4 id="使用明文通信"><a href="#使用明文通信" class="headerlink" title="使用明文通信"></a>使用明文通信</h4><p>http 没有加密功能， 无法对请求和响应的内容加密。内容在经过网络中间节点是容易被窃听。<br><img src="https://cdn.learnku.com/uploads/images/201702/06/4949/4y5A5AGezM.png" alt="file"></p><h4 id="不验证通信方身份"><a href="#不验证通信方身份" class="headerlink" title="不验证通信方身份"></a>不验证通信方身份</h4><p>HTTP  在请求和响应时， 不确认通信双方的身份。也就是说， 客户端无法确认返回的消息就是从真正的服务器上返回的， 有可能是从伪装的服务器上返回的。</p><p>同时， 服务端也不知道接收响应的客户端是否就是正真的目标客户端。<br>这就是中间人攻击。</p><p><img src="https://cdn.learnku.com/uploads/images/201702/06/4949/8CntTKYspj.png" alt="file"></p><h4 id="不验证报文完整性"><a href="#不验证报文完整性" class="headerlink" title="不验证报文完整性"></a>不验证报文完整性</h4><p>客户端端和服务端都无法确认收到的消息是否就是对方发送的原始消息， 有可能中间被修改。<br><img src="https://cdn.learnku.com/uploads/images/201702/06/4949/9DUNSe7JeX.png" alt="file"></p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>在不安全的网络上创建一安全信道。</p><h3 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a>什么是HTTPS</h3><blockquote><p>TLS是传输层安全协议（Transport Layer Security）的缩写，是一种对基于网络的传输的加密协议，可以在受信任的第三方公证基础上做双方的身份认证。</p></blockquote><blockquote><p>SSL是TLS的前身，现在已不再更新  &gt;  <a href="https://segmentfault.com/a/1190000002554673">TSL&#x2F;SSL 原理</a></p></blockquote><blockquote><p>HTTPS是在基于TLS&#x2F;SSL的安全套接字上的的应用层协议，除了传输层进行了加密外，其它与常规HTTP协议基本保持一致</p></blockquote><p>简单来说就是 HTTPS &#x3D; HTTP + TLS&#x2F;SSL</p><p><img src="https://cdn.learnku.com/uploads/images/201702/06/4949/mKHv5Gv2rd.png" alt="file"></p><h3 id="如何弥补HTTP缺点的"><a href="#如何弥补HTTP缺点的" class="headerlink" title="如何弥补HTTP缺点的"></a>如何弥补HTTP缺点的</h3><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><h5 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h5><ol><li><p>共享秘钥加密（对称密钥加密）</p><blockquote><p>使用双方共同拥有的单个密钥。这种密钥既用于加密，也用于解密，叫做机密密钥。</p></blockquote></li><li><p>公开秘钥加密（非对称加密）</p><blockquote><p>一个公钥和一个私钥，这两个密钥在数学上是相关的。在公钥加密中，公钥可在通信双方之间公开传递，或在公用储备库中发布，但相关的私钥是保密的。只有使用私钥才能解密用公钥加密的数据。使用私钥加密的数据只能用公钥解密。<img src="https://cdn.learnku.com/uploads/images/201702/06/4949/188EVQy31L.png" alt="file"></p></blockquote></li></ol><p>在HTTP应用中单纯的使用上面的任一中加密方式都存在问题：</p><ul><li>服务端如何安全的将秘钥发送给客户端？如果通信被窃听， 那么攻击者就在获得密文的同时获得秘钥，加密也就失去了意义。</li><li>如何让所有的客户端持有公钥？ 客户端如何确认收到的公开秘钥不是从中间人发送过来的假秘钥而是货真价实的真秘钥？</li></ul><h5 id="HTTPS-的加密方式"><a href="#HTTPS-的加密方式" class="headerlink" title="HTTPS 的加密方式"></a>HTTPS 的加密方式</h5><p>HTTPS 使用混合使用2中加密方式， 同时使用证书来证明公钥的正确性。</p><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>目的： 为保证双方传递信息的 真实性、可靠性、完整性。</p><p>CA:  证书认证中心 (Certificate Authority) 中心。是一个负责发放和管理数字证书的第三方权威机构。</p><p>认证流程:</p><ol><li><p>把证书请求 (ssl.csr) 发给证书机构。</p></li><li><p>CA 确认申请人身份后使用 CA 机构的私钥对服务器公钥进行数字签名， 同时把已签名的公钥分配给机构， 并且把证书和公钥及签名进行绑定。</p><blockquote><p>也就是证书里面包含了服务器公钥 + CA 对公钥的数字签名。</p></blockquote></li><li><p>服务器把证书发送给客户端（浏览器）</p></li><li><p>客户端使用CA机构的公钥验证证书上的数字签名。 如果验证通过，则表明：</p><ul><li>CA 的认证服务器是有效的</li><li>CA 的公钥是有效的</li><li>服务器的公钥是有效的</li></ul><blockquote><p>合法的CA机构的公钥是内置在浏览器中的。</p></blockquote></li><li><p>客户端使用服务器的公钥对报文加密</p></li><li><p>服务器使用私钥解密报文</p></li></ol><h3 id="既然我们有开源的-openssl，-为什么还要去购买ssl证书"><a href="#既然我们有开源的-openssl，-为什么还要去购买ssl证书" class="headerlink" title="既然我们有开源的 openssl， 为什么还要去购买ssl证书?"></a>既然我们有开源的 openssl， 为什么还要去购买ssl证书?</h3><h4 id="https-安全的前提"><a href="#https-安全的前提" class="headerlink" title="https 安全的前提"></a>https 安全的前提</h4><p>数字证书颁发机构（CA）被客户端和服务端绝对信任。</p><h4 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h4><blockquote><p><a href="https://segmentfault.com/a/1190000002569859">基于OpenSSL自建CA和颁发SSL证书</a></p></blockquote><p>就是自己扮演 CA 机构，自己给自己的服务器颁发证书。</p><p>由于自签名证书无法排除被中间人伪造的可能， 所有浏览器对自签名证书不信任，浏览的时候回给出风险提示。</p><p><img src="https://cdn.learnku.com/uploads/images/201702/06/4949/gVSU1kcUtQ.png" alt="file"></p><p><strong>因此， 只有值得信赖的第三方机构介入， 才能让植入在浏览器中的认证机构公开秘钥发挥作用， 从而借此证明服务器的真实性。</strong></p><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>Mozilla 和 Google 宣布对 WoSign 和 StartCom ( StartSSL ) 一年内新签发的所有SSL证书不信任。</p><blockquote><p>360 &gt; WoSign &gt; StartCom</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这是一篇内部分享文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.learnku.com/uploads/images/201702/06/4949/nx3raoaCAR.png&quot; alt=&quot;file&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="HTTPS" scheme="https://www.wewx.cn/tags/HTTPS/"/>
    
    <category term="网络" scheme="https://www.wewx.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 多账号的 SSH 配置</title>
    <link href="https://www.wewx.cn/2017/01/01/github-multi-account-ssh-configuration.html"/>
    <id>https://www.wewx.cn/2017/01/01/github-multi-account-ssh-configuration.html</id>
    <published>2017-01-01T00:00:00.000Z</published>
    <updated>2022-04-29T16:54:31.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有这样的情况，现在有 2 个 github 账号。现在都想使用 ssh key 的方式拉取代码。但是第二个账号无法使用，怎么办?</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1-生成-SSH-key"><a href="#1-生成-SSH-key" class="headerlink" title="1. 生成 SSH key"></a>1. 生成 SSH key</h3><p>1.1 生成第一个 key</p><pre><code>$ ssh-keygen -t rsa -C &quot;user1@email.com&quot;</code></pre><p>然后，回车确认即可。最后会生成</p><pre><code>id_rsaid_rsa.pub</code></pre><p>2个文件。</p><p>1.2 生成第二个 key</p><pre><code>$ ssh-keygen -t rsa -C &quot;user2@email.com&quot;</code></pre><p>注意，这里需要给 key 设置名称。要不然会覆盖第一个key，例如:</p><pre><code> ~/.ssh/id_rsa_user2@email.com</code></pre><p>至此，我们会得到4个文件。</p><h3 id="2-添加密钥到-SSH-agent-中"><a href="#2-添加密钥到-SSH-agent-中" class="headerlink" title="2. 添加密钥到 SSH agent 中"></a>2. 添加密钥到 SSH agent 中</h3><pre><code>$ ssh-agent bash$ ssh-add ~/.ssh/id_rsa_user2@email.com</code></pre><h3 id="3-修改-SSH-的-config-配置"><a href="#3-修改-SSH-的-config-配置" class="headerlink" title="3. 修改 SSH 的 config 配置"></a>3. 修改 SSH 的 config 配置</h3><pre><code>$ touch config    </code></pre><p>增加:</p><pre><code>HOST user2.githubhostname github.comIdentityFile ~/.ssh/id_rsa_user2@email.comUser user2@email.com</code></pre><h3 id="4-配置公钥"><a href="#4-配置公钥" class="headerlink" title="4. 配置公钥"></a>4. 配置公钥</h3><p>把 id_rsa.pub  和 <a href="mailto:&#105;&#x64;&#95;&#114;&#x73;&#97;&#95;&#x75;&#115;&#101;&#114;&#x32;&#64;&#x65;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x2e;&#x70;&#x75;&#x62;">&#105;&#x64;&#95;&#114;&#x73;&#97;&#95;&#x75;&#115;&#101;&#114;&#x32;&#64;&#x65;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x2e;&#x70;&#x75;&#x62;</a> 文件的内容添加到对应账号的公钥配置中。</p><h3 id="5-拉取项目"><a href="#5-拉取项目" class="headerlink" title="5. 拉取项目"></a>5. 拉取项目</h3><p>例如，user2 要克隆这个项目:</p><pre><code>git@github.com:EvaEngine/Dockerfiles.git</code></pre><p>则执行下面的命令即可:</p><pre><code>$ git clone git@user2.github:EvaEngine/Dockerfiles.git</code></pre><p>注意，地址中的 host 替换为了 config 中配置的名称。</p><p>搞定。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;有这样的情况，现在有 2 个 github 账号。现在都想使用 ssh key 的方式拉取代码。但是第二个账号无法使用，怎么办?&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Docker" scheme="https://www.wewx.cn/tags/Docker/"/>
    
    <category term="容器" scheme="https://www.wewx.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
</feed>
