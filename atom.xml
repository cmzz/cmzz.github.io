<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吹雨听风</title>
  
  <subtitle>热爱写代码.</subtitle>
  <link href="https://www.wewx.cn/atom.xml" rel="self"/>
  
  <link href="https://www.wewx.cn/"/>
  <updated>2022-11-16T02:27:30.954Z</updated>
  <id>https://www.wewx.cn/</id>
  
  <author>
    <name>吹雨听风</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go gRPC 客户端内存泄漏问题排查</title>
    <link href="https://www.wewx.cn/2022/11/15/grpc-client-memory-not-release-problem.html"/>
    <id>https://www.wewx.cn/2022/11/15/grpc-client-memory-not-release-problem.html</id>
    <published>2022-11-15T00:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>近期对系统进行压力测试的过程发现随着请求的增加，程序占用内存会持续增长的情况，且增长没有上限，最高占用系统内存超过 90%。</p><p>在线系统增加 <code>pprof</code> 部署后，开始 debug 与问题排查。</p><h2 id="从现象开始定位问题"><a href="#从现象开始定位问题" class="headerlink" title="从现象开始定位问题"></a>从现象开始定位问题</h2><p>很明确的问题，内存占用过高。因此更直接查看了内存分析。通过分析 <code>pprof/heap</code> 文件，得到了如下的调用堆栈，从图中可以看到， newBufWriter + NewReaderSize 共计占用了 2.5GB 内存，显得很不正常。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h85ywm8sntj30vm0u0tcm.jpg"></p><p>系统本身是一个 Web 应用，不过在其请求处理的过程中需要通过 gRPC 调用几个外部的服务，但即使是 500 的并发，占如如此多的内存也不是一个正常现象。</p><h2 id="从问题开始开析原因"><a href="#从问题开始开析原因" class="headerlink" title="从问题开始开析原因"></a>从问题开始开析原因</h2><p>既然已经找到 gRPC 客户端占用了最多的内存的证据，那就开始从 gRPC 调用代码开始分析原因。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err = grpc.Dial( server, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())</span><br></pre></td></tr></table></figure><p>这是程序中初始化 gRPC 客户端的代码，简单直接，从 gRPC 官方的文档上 copy 来的。</p><p>进入 Dail 内部：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DialContext(context.Background(), target, opts...)</span><br></pre></td></tr></table></figure><p>请注意，这直接使用了默认的 Background Context. 根据文档的介绍， ctx 参数可以控制连接的取消和<strong>超时</strong>。</p><p>如果要使 ctx 的超时生效，必须要同时使用 <code>grpc.WithBlock()</code> ，因为 gRPC 默认是使用非阻塞的 http2 客户端。</p><p>那 ctx 作用是啥呢？请看官方的说法。ctx 可以用来控制 pending 的超时时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// In the blocking case, ctx can be used to cancel or expire the pending  </span><br><span class="line">// connection. Once this function returns, the cancellation and expiration of  </span><br><span class="line">// ctx will be noop. Users should call ClientConn.Close to terminate all the// pending operations after this function returns.</span><br></pre></td></tr></table></figure><p>那是不是并发大太，外部的服务承受不了如大的流量导致了大量 penging 状态的请求没有释放？</p><p>于是，我们将代码改成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second)  </span><br><span class="line">defer cancel()</span><br><span class="line">conn, err = grpc.DialContext(ctx, address, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())</span><br></pre></td></tr></table></figure><p>增加了 timeout，但将新的代码上线后，内部占用的问题并没有解决！继续看文档，此 timeout 仅作用于链接建立 block 类型的连接建立阶段。</p><h2 id="网上的答案"><a href="#网上的答案" class="headerlink" title="网上的答案"></a>网上的答案</h2><p>网上搜索的答案，几乎千篇一律的说是在 Server 端指定的 KeepAlive 参数，用于在客户端没有心跳时自动的关闭链接。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h86q1btnr8j316i0u045f.jpg"></p><p>服务端不是我能控制的啊，那不管服务端，可以直接在客户端直接应用 KeepAlive 吗？答案是不能。</p><p><code>keepalive.ClientParameters</code> 是客户端的 keepalive 参数配饰的 grpc.option，其注释中有明确提示：</p><blockquote><p>&#x2F;&#x2F; Make sure these parameters are set in<br>   &#x2F;&#x2F; coordination with the keepalive policy on the server, as incompatible<br>   &#x2F;&#x2F; settings can result in closing of connection.</p></blockquote><p><code>ClientParameters</code> 和<code>ServerParameters</code> 需要搭配使用，使用不当会导致链接错误的被关闭。</p><h2 id="ectd-如何使用-gRPC-Client"><a href="#ectd-如何使用-gRPC-Client" class="headerlink" title="ectd 如何使用 gRPC Client"></a>ectd 如何使用 gRPC Client</h2><p>etcd 在 v3 中全面使用了 gRPC，因此想看看在 etcd 中是如何去使用的，这里贴一下 ectd Client 初始化代码：</p><p><a href="https://github.com/etcd-io/etcd/blob/bf5c936ff1de422b48cc313435aa40ef6f2057ac/client/v3/client.go#L289">etcd&#x2F;client.go at bf5c936ff1de422b48cc313435aa40ef6f2057ac · etcd-io&#x2F;etcd · GitHub</a></p><h2 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h2><p>etcd 在初始化 Connection 时考虑了如 TimeOut、KeepAlive 相关的可选项，可谓是使用的标杆。参照其代对程序 Connection 的建立部分做了一些完善，不过无法仅通过 gRPC Client 的连接配置来解决这个问题，但这个问题又确确实实的发生在 gRPC Client 上，那是不是我们代码对 gRPC 使用不当？</p><p>于是，把所有调用 gRPC 的代码都找出来，共有 10 来处，一处一处的排查。</p><p>系统因需要链接多个外部的 gRPC Server，应止在程序层面有一些封装用于获取客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func GetAaaRPCClient() *grpc.Client</span><br><span class="line">func GetBbbRPCClient() *grpc.Client</span><br></pre></td></tr></table></figure><p>重新 Review 该部份代码，没有问题！且对客户端做了复用。继续 Review 余下部份，确实找到了 3 处不正确的使用：没用复用上面的 <code>GetClient</code>，而是在代码直接初始化客户端，且没有主动关闭。刚好，这三处代码码的 API 也在压测范围之内，那没错，问题就出在这了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>gRPC 客户端在其内部做了连接的优化与管理，虽并不需要用户在程序中去管理连接池，但在使用时依然需要注意：</p><ol><li>建议只为每个 Service 建立一个客户端</li><li>如果需要为每个请求建立连接，那么一定不要忘了关闭</li><li>Server 端建议配置 KeepAlive 参数，参考 <a href="https://pkg.go.dev/google.golang.org/grpc/keepalive#ServerParameters">keepalive package - google.golang.org&#x2F;grpc&#x2F;keepalive - Go Packages</a> 并在文档中告知调用方</li><li>如果 Server 明确说明了 KeepAlive，客户端在建立连接时，建议指定相关 Option，参考 <a href="https://pkg.go.dev/google.golang.org/grpc#KeepaliveParams">grpc package - google.golang.org&#x2F;grpc - Go Packages</a></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mycodesmells.com/post/pooling-grpc-connections">Pooling gRPC Connections - My Code Smells!</a></li><li><a href="https://stackoverflow.com/questions/56067076/grpc-connection-management-in-golang">go - GRPC Connection Management in Golang - Stack Overflow</a></li><li><a href="https://groups.google.com/g/grpc-io/c/KGlqYrTOjqI">transport.newBufWrite go grpc not releasing memory</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期对系统进行压力测试的过程发现随着请求的增加，程序占用内存会持续增长的情况，且增长没有上限，最高占用系统内存超过 90%。&lt;/p&gt;
&lt;p&gt;在线系统增加 &lt;code&gt;pprof&lt;/code&gt; 部署后，开始 debug 与问题排查。&lt;/p&gt;
&lt;h2 id=&quot;从现象开始定位问题</summary>
      
    
    
    
    
    <category term="golang" scheme="https://www.wewx.cn/tags/golang/"/>
    
    <category term="gRPC" scheme="https://www.wewx.cn/tags/gRPC/"/>
    
    <category term="编程" scheme="https://www.wewx.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MinIO Go Client OOM 引发的故障排查</title>
    <link href="https://www.wewx.cn/2022/09/02/minio-client-oom.html"/>
    <id>https://www.wewx.cn/2022/09/02/minio-client-oom.html</id>
    <published>2022-09-02T00:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本周我们系统为了提升包含多文件的任务处理效率，将原来的串行化文件处理做了一优化，改成了协程并行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wg.Add(<span class="built_in">len</span>(fileList))</span><br><span class="line"><span class="keyword">for</span> _, pdf := <span class="keyword">range</span> fileList &#123;</span><br><span class="line">    SplitPdfFile(f)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><p>SplitPdfFile 会调用 文件服务 进行 PDF 文件处理 （按页分割、合并页码）。</p><h2 id="问题浮现"><a href="#问题浮现" class="headerlink" title="问题浮现"></a>问题浮现</h2><p>代码上线后，完了，功能完全不可用。原因是文件服务返回了 503 的错误响应。</p><h2 id="问题排查与分析过程"><a href="#问题排查与分析过程" class="headerlink" title="问题排查与分析过程"></a>问题排查与分析过程</h2><h3 id="1-为什么会-503"><a href="#1-为什么会-503" class="headerlink" title="1. 为什么会 503"></a>1. 为什么会 503</h3><p>通过 rancher 查看，服务被重启了。由于是服务直接被 k8s 重启，程序并没有记录日志，而且我们也无法进入服务器从外部查看 k8s 日志，没有进一步的信息，但其他 API 并不到返回 503，仅仅是这一个 API，于是在当时盲猜了几个原因：</p><ul><li>是有没有 recovery 的 panic 导致程序异常了</li><li>因为是文件处理，可能文件异常</li></ul><p>进一步分析与验证：</p><ul><li>程序在全局有注册 recovery，按道理所有的 painc 都会被捕获并销记录错误日志，但此情况下是没有任务日志被记录，故排除。</li><li>对于第二点，把对应文件放在本地进行处理，程序完全正常，故排除。</li></ul><p>关注点再次回到容器上，容器为什么会重启，重启的原因是什么？但我们能用的仅有 rancher，通过 google 搜索神器，我们找到在服务的 yaml 文件的 State 节点下，会记录容器上次重启的原因：<strong>OOMKilled</strong></p><h3 id="2-什么原因导致程序-OOM？"><a href="#2-什么原因导致程序-OOM？" class="headerlink" title="2. 什么原因导致程序 OOM？"></a>2. 什么原因导致程序 OOM？</h3><p>老实讲，没有想过这个不太大的文件服务会 OOM，通过观察发现程序初始启动时消耗的内存大约在 1300MB，请求部分 API 后会稳定在 1500MB 左右，而服务中的内存 limit 是 2Gi，按道理是足够的。</p><p>另外还观察到，只要请求 PDF 文件处理 API，每次请求内点点用就会增加大约 0.6 ～ 1.5g，且不会释放，多来几次就被 kill 了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5sfaox8vtj20rk01kjrh.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5sfav9l6mj20ty01m74f.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5sfb1yf6aj20so01o3yn.jpg"></p><p>这个现象 100%复现，也就是可以进一步确认是 PDF 文件处理会导致 OOM</p><h3 id="3-会是不正确使用文件引发的-OOM-吗？"><a href="#3-会是不正确使用文件引发的-OOM-吗？" class="headerlink" title="3. 会是不正确使用文件引发的 OOM 吗？"></a>3. 会是不正确使用文件引发的 OOM 吗？</h3><p>这是一个 PDF 文件处理功能，那是否存在打开的文件忘关了、重复载入了文件的可能性？不排除这种可能性，于是花费了一些时间对系统的全部文件操作进行审查，顺路优化了一些代码：</p><p>Before</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f := os.Open(path)</span><br><span class="line"></span><br><span class="line">anotherFun(f)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anotherFun</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f := os.Open(path)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">anotherFun(f)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anotherFun</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">     <span class="comment">// code</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">defer</span> f.Close()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Before</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> fileList &#123;</span><br><span class="line">   f := os.Open(path)</span><br><span class="line">   <span class="keyword">defer</span> f.Close()</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> fileList &#123;</span><br><span class="line">    f := os.Open(path)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">    _ = f.Close()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>仔细排查文件操作之后，所有文件使用都已规范、文件关闭时机都很合理、也不存在重复读入的问题，但在线上问题依旧！</p><h3 id="4-上神器-pprof"><a href="#4-上神器-pprof" class="headerlink" title="4. 上神器 pprof"></a>4. 上神器 pprof</h3><p>借助pprof，我们观察到在本机运行，即使是 50 个并发循环 10 次这样量级内存占用依然是稳定的！并不会像服务器上一样出现 OOM 并引起崩溃的情况。</p><p>程序启动</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5sfa7zki5j21800j0n27.jpg"></p><p>并发请求后</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5sfagqbglj215o0is76u.jpg"></p><p>由此基本可以确定问题仅出现在线上环境，于是把线上的 heap 信息down 到本地并使用 pprof 时行分析，最后发现是 MinIO Client 占用了大量内存没有释放。</p><h3 id="5-为啥在本地没有复现？"><a href="#5-为啥在本地没有复现？" class="headerlink" title="5. 为啥在本地没有复现？"></a>5. 为啥在本地没有复现？</h3><p>定位到问大概的问题，我们再回到本地，分析本地不能复现的原因。经过一遍一遍撸代码，发现在本地运行模式和线上有一些差异。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5sf94dstyj20u00uh760.jpg"></p><p>如果程序运行在本机模式下，程序并没有经过 MinIO Client，而是直连的 OSS，也就异致问题不能在本机进行复现。</p><h3 id="6-最后，再来深究一下-MinIO-Client-为什么会导致-OOM？"><a href="#6-最后，再来深究一下-MinIO-Client-为什么会导致-OOM？" class="headerlink" title="6. 最后，再来深究一下 MinIO Client 为什么会导致 OOM？"></a>6. 最后，再来深究一下 MinIO Client 为什么会导致 OOM？</h3><p>如果使用 “minio client oom” 在 google 进行搜索，会发现已有相关记录而并非是个例。 大家遇到的问题和我们是一样的。</p><p>OOM 其实是由 mc.PutObject() 这个函数触发，其第二个参数 size 如果传递 -1 则会引起 OOM。</p><p>参数 Size 的作用是指定要上传的文件大小，MinIO 会根据不同的文件大小使用不同的上传策略。对于没有指定大不的文件（-1），MinIO Client 会认为该文件的大小为 5TB，并以 5G 的分片大小进行上传，每次会将该片的全部字节读入内存中，那如果如时操作多个文件，就会导致内存耗尽。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PutObject creates an object in a bucket.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You must have WRITE permissions on a bucket to create an object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  - For size smaller than 16MiB PutObject automatically does a</span></span><br><span class="line"><span class="comment">//    single atomic PUT operation.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  - For size larger than 16MiB PutObject automatically does a</span></span><br><span class="line"><span class="comment">//    multipart upload operation.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  - For size input as -1 PutObject does a multipart Put operation</span></span><br><span class="line"><span class="comment">//    until input stream reaches EOF. Maximum object size that can</span></span><br><span class="line"><span class="comment">//    be uploaded through this operation will be 5TiB.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    WARNING: Passing down &#x27;-1&#x27; will use memory and these cannot</span></span><br><span class="line"><span class="comment">//    be reused for best outcomes for PutObject(), pass the size always.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> Upon errors during upload multipart operation is entirely aborted.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> PutObject(ctx context.Context, bucketName, objectName <span class="type">string</span>, reader io.Reader, objectSize <span class="type">int64</span>,</span><br><span class="line">   opts PutObjectOptions) (info UploadInfo, err <span class="type">error</span>) &#123;</span><br></pre></td></tr></table></figure><p>其实，PutObject 方法原型的注释中，Waring 有提醒我们，使用该方法时都需要传递文件尺寸，奈何一开始没有注意到，从而掉入到了坑里。</p><h3 id="7-解决方法"><a href="#7-解决方法" class="headerlink" title="7. 解决方法"></a>7. 解决方法</h3><p>找到了问题，那解决方案也很简单了。在 size 处传递正确的文件尺寸即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>从业务上考虑我们要设置多大的文件</li><li>根据文件 Size 上限、最多支持 10, 000 part 、并发度控制，容器内存大小等因素来指定 part 大小</li><li>minio 需要根据 part size 的大小来确定最高的并发度来防止容器 OOM，并且需要控制到 minio 驱动层，而不是业务层</li><li>虽然 Minio S3 接口不支持流式，但支持分片，所以上传大文件的时候仍然需要用流式，而不是把大文件都加载到内存才开始上传到 Minio</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本周我们系统为了提升包含多文件的任务处理效率，将原来的串行化文件处理做了一优化，改成了协程并行。&lt;/p&gt;
&lt;figure class=&quot;hi</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Docker" scheme="https://www.wewx.cn/tags/Docker/"/>
    
    <category term="MinIO" scheme="https://www.wewx.cn/tags/MinIO/"/>
    
  </entry>
  
  <entry>
    <title>Go 实时日志收集</title>
    <link href="https://www.wewx.cn/2022/08/12/golang-log-collection.html"/>
    <id>https://www.wewx.cn/2022/08/12/golang-log-collection.html</id>
    <published>2022-08-12T00:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>通常基础系统都会自动处理与收集日志，并不太需要应用来收集。但利用 go 的并发与携程能力，要实现实时的日志收集也是非常简单。</p><p>功能设计</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h54ajve0rlj20qf0d3q4e.jpg" alt="日志收集程序设计"></p><ul><li>主程序向指定的日志文件记录日志</li><li>收集程序独立于主程序之外，通过实时监控程序日志的方式即时读取新写入的日志</li><li>在读取到日志行之后，将其通过 channel 传送给日志处理进程</li><li>处理完成后视需要存储到 <code>es / logstash / influxdb</code></li></ul><p>优点</p><p>日志收集程序独立于主程序之外运行，对程序无侵入性。</p><p>实现</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> logCollection</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;bufio&quot;</span></span><br><span class="line">   <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">   <span class="string">&quot;errors&quot;</span></span><br><span class="line">   <span class="string">&quot;io&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;strings&quot;</span></span><br><span class="line">   <span class="string">&quot;syscall&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logIno <span class="type">uint64</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> logCount <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LogLine <span class="keyword">struct</span> &#123;</span><br><span class="line">   Level      <span class="type">string</span>  <span class="string">`json:&quot;level&quot;`</span></span><br><span class="line">   TS         <span class="type">float64</span> <span class="string">`json:&quot;ts&quot;`</span></span><br><span class="line">   Caller     <span class="type">string</span>  <span class="string">`json:&quot;caller&quot;`</span></span><br><span class="line">   Msg        <span class="type">string</span>  <span class="string">`json:&quot;msg&quot;`</span></span><br><span class="line">   StackTrace <span class="type">string</span>  <span class="string">`json:&quot;stacktrace&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFileIno</span><span class="params">(path <span class="type">string</span>)</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">   fileinfo, _ := os.Stat(path)</span><br><span class="line">   stat, ok := fileinfo.Sys().(*syscall.Stat_t)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> stat.Ino</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openLog</span><span class="params">(path <span class="type">string</span>, rc <span class="keyword">chan</span> []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> f *os.File</span><br><span class="line">   <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// create file if not exists</span></span><br><span class="line">   <span class="keyword">if</span> _, err = os.Stat(path); errors.Is(err, os.ErrNotExist) &#123;</span><br><span class="line">      f, err = os.Create(path)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      f, err = os.Open(path)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   logIno = getFileIno(path)</span><br><span class="line">   <span class="keyword">if</span> logIno == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(errors.New(<span class="string">&quot;open log file failed&quot;</span>))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">      _ = f.Close()</span><br><span class="line">   &#125;(f)</span><br><span class="line"></span><br><span class="line">   f.Seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">   buf := bufio.NewReader(f)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// check file ino</span></span><br><span class="line">      <span class="comment">// if changed, reopen file</span></span><br><span class="line">      <span class="keyword">if</span> logIno != getFileIno(path) &#123;</span><br><span class="line">         variable.Logger.Error(<span class="string">&quot;openLog logIno != new : &quot;</span>, logIno)</span><br><span class="line">         _ = f.Close()</span><br><span class="line"></span><br><span class="line">         f, err = os.Open(path)</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            variable.Logger.ErrorF(<span class="string">&quot;open log file failed: %s\n&quot;</span>, err)</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         logIno = getFileIno(path)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      line, err := buf.ReadBytes(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">switch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> err == io.EOF:</span><br><span class="line">         time.Sleep(time.Second)</span><br><span class="line">      <span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         rc &lt;- line[:<span class="built_in">len</span>(line)<span class="number">-1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(path <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">         time.Sleep(time.Second)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   c := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">byte</span>)</span><br><span class="line">   <span class="keyword">go</span> openLog(path, c)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      line := &lt;-c</span><br><span class="line">      process(line)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(line []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> logLine LogLine</span><br><span class="line">   err := json.Unmarshal(line, &amp;logLine)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> logLine.Level == <span class="string">&quot;debug&quot;</span> || logLine.Level == <span class="string">&quot;info&quot;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 精简 trace</span></span><br><span class="line">   traces := strings.Split(logLine.StackTrace, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(traces) &gt; <span class="number">2</span> &#123;</span><br><span class="line">      traces = traces[<span class="number">2</span>:]</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(traces) &gt; <span class="number">3</span> &#123;</span><br><span class="line">         traces = traces[:<span class="number">3</span>]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   write(&amp;logLine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(log *LogLine)</span></span> &#123;</span><br><span class="line">   <span class="comment">// write to es</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面代码中的一个小细节：</p><p>在我们系统中，主程只负责向 <code>app.log</code> 写日志，但 <code>app.log</code> 会在每天凌晨被重命名为 <code>app_2022-08-10.log</code> 以实现日志分割。</p><p>那么如何检测文件被移动呢？</p><p>上面代码中的实现是通过 <code>file index no, fio</code> 来判断，如果打开的 <code>app.log</code> fio 与磁盘上 <code>app.log</code> 文件的 fio 不一致，则认为是创建了新的日志文件，此时再重新打开日志即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通常基础系统都会自动处理与收集日志，并不太需要应用来收集。但利用 go 的并发与携程能力，要实现实时的日志收集也是非常简单。&lt;/p&gt;
&lt;p&gt;功能设计&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h54a</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="golang" scheme="https://www.wewx.cn/tags/golang/"/>
    
    <category term="并发编程" scheme="https://www.wewx.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 应用从 MySQL 迁移到 SQLite</title>
    <link href="https://www.wewx.cn/2022/06/22/laravel-from-mysql-migrate-to-sqlite.html"/>
    <id>https://www.wewx.cn/2022/06/22/laravel-from-mysql-migrate-to-sqlite.html</id>
    <published>2022-06-22T00:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>阿里云提醒 RDS 要续费了，几大百一年但实际上现在只有几个小型的应用在用 MySQL。疫情之下，本着开源节流的原则，打算把 MySQL 给替换成 SQLite 以便省点银子。</p><p>之前对于 SQLite 也就是了解的程度但并没有实际使用，应此在正式切换之前还需要做一些准备工作。</p><p>SQLite 和 MySQL 类似，都是一种 关系数据库管理系统 （RDBMS，Relational Database Management System）。以数据表作为基础的数据存储系统。</p><h2 id="SQLite-的优缺点"><a href="#SQLite-的优缺点" class="headerlink" title="SQLite 的优缺点"></a>SQLite 的优缺点</h2><blockquote><p>Small. Fast. Reliable.</p></blockquote><p>SQLite 是一款 C 编写的关系数据库。正如其名，SQLite 并非是作为一个独立的进程运行，也不需要使用特这的通信息协议与应用程序连接，而是直接作为应用程序的一部分随程序发布，这样的特性使 SQLite 非常的轻量级与易于使用，在手机、电脑、嵌入式设备、应用内嵌数据库等方面有着非常广泛的应用。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3h1e224qkj20bb034q2u.jpg" alt="https://www.sqlitetutorial.net/what-is-sqlite/"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>零配置，易使用</li><li>可跨平台。SQLite 基于特定格式的单个文件，可移动性和跨平台特性好</li><li>备份容易。直接使用 <code>cp</code> 复制数据库文件即可</li><li>开方测试方便。基于 SQLite 的自<a href="https://www.sqlite.org/selfcontained.html">包含特性</a>，使其的以来非常少，在开发过程中可作为替代手段，待上线后有需要再改为其他 RDBMS</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>没有用户系统</li><li>不支持网络访问</li><li>不适用于大型程序</li><li>提升性能的手段有限</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>嵌入式设备 </li><li>物联设备</li><li>作为 excel 的替代</li><li>小型应用</li><li>小量数据分析</li><li>数据缓存 </li><li>开发和测试阶段的临时方案</li><li>教学目的</li></ul><h2 id="MySQL-的优缺点"><a href="#MySQL-的优缺点" class="headerlink" title="MySQL 的优缺点"></a>MySQL 的优缺点</h2><p>MySQL 是当前最为热门的关系数据库（RDBMS），目前世界上大多数应用都在使用它。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3h1iy6ys1j20gs06m0sw.jpg" alt="https://www.sqlitetutorial.net/what-is-sqlite/"></p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>功能强大</li><li>用户管理功能</li><li>内置更多的安全功能</li><li>更精细的事务和锁机制</li><li>更好的并发性能</li><li>支持网络访问</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>数据跨平台性差</li><li>可靠性问题</li><li>发展停滞，尽管 MySQL 仍是开源软件，但自从被收购之后发展已放缓</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>分布式协作</li><li>大流量网站或中型应用系统</li><li>事务支持的程序</li><li>需要大量数据写入</li><li>存储更大规模数据量</li></ul><h2 id="Laravel-应用替换"><a href="#Laravel-应用替换" class="headerlink" title="Laravel 应用替换"></a>Laravel 应用替换</h2><p><code>mysql-to-sqlite3</code> 是一款 Python 的程序，可以将 MySQL 的数据库转换为 SQLite3 格式的数据库。</p><h3 id="安装并运行转换"><a href="#安装并运行转换" class="headerlink" title="安装并运行转换"></a>安装并运行转换</h3><pre><code>pip install mysql-to-sqlite3mysql2sqlite --helpmysql2sqlite -f ./sqlite.db \-d mysql数据库名称 \-u mysql数据库用户名 \--mysql-password mysql数据库密码 \-h mysql数据库地址</code></pre><p>上面的命令可以生成 <code>sqlite.db</code> 文件，直接使用即可。</p><h3 id="调整-Laravel-配置"><a href="#调整-Laravel-配置" class="headerlink" title="调整 Laravel 配置"></a>调整 Laravel 配置</h3><pre><code>DB_CONNECTION=sqliteDB_DATABASE=/absolute/path/to/database.sqlite</code></pre><p>直接修改 <code>.env</code> 中的 MYSQL 配置，参考上面的的就行。注意 <code>database.sqlite</code> 文件需要有可写权限。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阿里云提醒 RDS 要续费了，几大百一年但实际上现在只有几个小型的应用在用 MySQL。疫情之下，本着开源节流的原则，打算把 MySQL 给替换成 SQLite 以便省点银子。&lt;/p&gt;
&lt;p&gt;之前对于 SQLite 也就是了解的程度但并没有实际使用，应此在正式切换之前还需要</summary>
      
    
    
    
    
    <category term="Laravel" scheme="https://www.wewx.cn/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>威联通NAS进阶玩法之 Portainer</title>
    <link href="https://www.wewx.cn/2022/06/19/Portainer-of-QNAP-NA-advanced-gameplay.html"/>
    <id>https://www.wewx.cn/2022/06/19/Portainer-of-QNAP-NA-advanced-gameplay.html</id>
    <published>2022-06-19T00:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>Portainer 是一个可视化的容器镜像的图形管理工具，利用Portainer 可以轻松构建，管理和维护Docker环境。 而且完全免费，基于容器化的安装方式，方便高效部署。</p><p>官网地址：<a href="https://www.portainer.io/">https://www.portainer.io/</a></p><h3 id="登录NAS"><a href="#登录NAS" class="headerlink" title="登录NAS"></a>登录NAS</h3><p>首先在 NAS 控制面板开启 SSH 登录功能。接着使用 <code>admin</code> 账号密码登录（只能使用 admin)。</p><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><p>docker search portainer</p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>docker pull portainer&#x2F;portainer</p><h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><pre><code>docker run -d -p 9001:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /portainer_data:/data/portainer/portainer portainer/portainer</code></pre><p>参数介绍：</p><ul><li>“-d”代表”后台运行容器，并返回容器ID”</li><li>“-p”代表”容器内部端口随机映射到主机的高端口”，前面的9000是容器默认端口，后面的9000是安装后映射的端口（冒号前后）</li><li>“–name” 代表容器的名字</li><li>“–restart always”代表总是Docker启动后容器自动启动</li><li>“-v”表示路径映射，portainer的路径映射用默认就行，如果为了方便迁移可以映射到Nas的实体路径</li></ul><h3 id="访问Portainer容器"><a href="#访问Portainer容器" class="headerlink" title="访问Portainer容器"></a>访问Portainer容器</h3><pre><code>http://&lt;你的NAS IP地址&gt;:9001</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Portainer 是一个可视化的容器镜像的图形管理工具，利用Portainer 可以轻松构建，管理和维护Docker环境。 而且完全免费，基于容器化的安装方式，方便高效部署。&lt;/p&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://www.portainer.io/&quot;&gt;</summary>
      
    
    
    
    
    <category term="NAS" scheme="https://www.wewx.cn/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>我的长沙初印象</title>
    <link href="https://www.wewx.cn/2022/06/03/first-impressions-of-changsha.html"/>
    <id>https://www.wewx.cn/2022/06/03/first-impressions-of-changsha.html</id>
    <published>2022-06-03T02:36:48.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>4月底我们团队确定了要去长沙出差的计划，对于这种长达一个月、在陌生城市出差，虽拒我心底是拒绝的但又无可奈何，基于这种抵触的情绪订了5.2号伴晚的车票。从深圳出发历经3个半小时高铁，到达住处大约是晚上10点，不算晚。</p><h3 id="好吃不贵"><a href="#好吃不贵" class="headerlink" title="好吃不贵"></a>好吃不贵</h3><p>饿了！<br>晚饭还没吃，可能是真饿也或许是馋长沙美食！下楼向大堂前台问了问周边商业分布情况便小跑着向附近一条小吃街而去，去寻找长沙同事口中盛赞的美味。然而，在那条不长的街道上只有少数几个小吃店还在营业着，其他大多已经休息。走至街口最近的一家米粉店推门而入，看到墙上的菜单，价格是7-13元之间。这价格让人感觉仿佛回到10年前。<br>“老板， 一碗杀猪粉”。等待了几分钟，端上来一大碗，猪杂、肉量还挺足，一碗干光不仅赶走深夜的饥饿感，还认我收获了大大的满足感与城市生活的幸福感。</p><h3 id="茶颜悦色"><a href="#茶颜悦色" class="headerlink" title="茶颜悦色"></a>茶颜悦色</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3fzyangmuj20u00mignh.jpg" alt="茶颜悦色"><br>初到长沙就直奔茶颜悦色而去，但其实它根本不用找。街上几百米就有一家。但又似乎每家店都需要等待很久，也是，毕竟好看又好喝的奶茶谁能拒绝。<br>这一个月，几乎每天一杯，我要离开之前把 1 年的茶颜都喝掉！</p><h3 id="连着下40天雨"><a href="#连着下40天雨" class="headerlink" title="连着下40天雨"></a>连着下40天雨</h3><p>“清时时节雨纷纷”。但我们是5月来的长沙啊，整整2个星期了一直在下雨，都给我整蒙了，不过2个星期还不是真相啊，听同事说下了接近40天了快。。。</p><p>这可真是有点吓人，得要买多少衣服才够换？我只带了2身衣服，想逃了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3f6kfxmz4j20ic0dr3zc.jpg" alt="这个图没有大桥"></p><h3 id="司机真的不会让行人"><a href="#司机真的不会让行人" class="headerlink" title="司机真的不会让行人"></a>司机真的不会让行人</h3><p>或许是习惯了深圳路口的车让人，所以在过马路口时，见车还远就打算走来着。但是刚走上斑马线，急速驶来的汽车根本就没减速的意思，吓得我们不得不后退让行。<br>事后和本地同事说起，他们都觉得这很正常。这在长沙少有“车认人”的，因此提醒我们过马路一定得小心。<br>但是… 《道路交通安全法》规定在以下四种情形车需礼让行人啊：一是当路口的右转弯车道和人行横道都是绿灯时，机动车要停车让行人先行;二是在路中遇到人行横道(没有信号灯控制)而行人正在通过人行横道或正欲通过时，机动车同样要停车让行人先行;三是在没有交通信号的道路上，机动车遇行人横过道路，还是应当避让;四是机动车行经人行横道时要减速，遇行人迟疑或左顾右盼不敢过马路，要主动示意行人先行。 </p><h3 id="辣出眼泪"><a href="#辣出眼泪" class="headerlink" title="辣出眼泪"></a>辣出眼泪</h3><p>辣！辣！辣！这是个无辣不欢的省份！<br>第一周末，同事接接待了我们，请大家吃了2022的第一顿小龙虾，做法很多，但我只能感到一种口味：辣！</p><p>某日，在老长沙同事的带领下我们去走街串巷探索外地人可能并不知道隐藏店铺。其中有一家叫“盟重”的烧烤店。对，就是《热血传奇》中的盟重！猜想老板一定是一个资深且高端的传奇玩家，整个店铺装修得很有沙漠风格，就连菜品名称也是“半月”和“烈火”  ！同事照顾我们这些从广东而去的小伙伴特地点了“微辣”烧烤，聊了会，菜品上桌，开始撸串。</p><p>斯！辣！ 长沙朋友和有我们，对于“微辣”完全是两种不同的理解，他们吃着平平淡淡，但我一口下去就爆泪…惹不起！</p><h3 id="幸福感"><a href="#幸福感" class="headerlink" title="幸福感"></a>幸福感</h3><p>连续13年获评“中国最具幸福感城市”，长沙的幸福感被当地同事称道！<br>长沙给生活在这座城市里的人带来最大的幸福感，就是较高的收入性价比、便利的交通和丰富的文化生活。<br>除此之外，长沙也是千年古城、风韵之都、时光老城、美食之城…</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3fzwuhflhj20fa0mvjt8.jpg" alt="长沙"></p><p>长沙，爱了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;4月底我们团队确定了要去长沙出差的计划，对于这种长达一个月、在陌生城市出差，虽拒我心底是拒绝的但又无可奈何，基于这种抵触的情绪订了5.2号伴晚的车票。从深圳出发历经3个半小时高铁，到达住处大约是晚上10点，不算晚。&lt;/p&gt;
&lt;h3 id=&quot;好吃不贵&quot;&gt;&lt;a href=&quot;#好</summary>
      
    
    
    
    
    <category term="长沙" scheme="https://www.wewx.cn/tags/%E9%95%BF%E6%B2%99/"/>
    
  </entry>
  
  <entry>
    <title>Web 前端直接渲染 Office 格式文档的几种方案</title>
    <link href="https://www.wewx.cn/2022/05/30/office-docs-online-preview.html"/>
    <id>https://www.wewx.cn/2022/05/30/office-docs-online-preview.html</id>
    <published>2022-05-30T00:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>在一些中台系统中或管理后台系统中，在线预览 Office 文档是个比较常见的需求，奈何浏览器的支持有限在做相关功能时踩了一些坑。</p><h2 id="通用解决方案"><a href="#通用解决方案" class="headerlink" title="通用解决方案"></a>通用解决方案</h2><h3 id="通过-PDF-格式预览"><a href="#通过-PDF-格式预览" class="headerlink" title="通过 PDF 格式预览"></a>通过 PDF 格式预览</h3><p>现在注流的浏览器已经支持了 PDF 文件的在线预览，但是对于 word &#x2F; excel 等格式文件，浏览器的还没有提供直接的支持。应此在需要预览 word 或 excel 文件时，可以考虑先将其转换为 PDF 文件，再通过浏览器的能力渲染。</p><p>渲染 PDF 文件非常简单，比较常见的有下面 2 种方式：</p><ul><li>链接</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Open a PDF file <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/uploads/media/example.pdf&quot;</span>&gt;</span>example<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击链接，浏览器会新一个 Tab 来打开 PDF 文件进行预览。</p><ul><li>在 html 中通过 iframe 来渲染</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;/uploads/media/example.pdf&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">height</span>=<span class="string">&quot;500px&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2 种方式都是基于浏览器内置能力实现，有点和缺点也都比较明显：</p><ul><li>优点：自带“打印”，“搜索”，“翻页”等功能，强大且实现非常简单方便</li><li>缺点：不同浏览器的pdf工具样式不一，且无法满足个性化需求，比如：禁止打印，下载等</li></ul><h3 id="PDF-js"><a href="#PDF-js" class="headerlink" title="PDF.js"></a>PDF.js</h3><p><a href="https://mozilla.github.io/pdf.js">PDF.js</a> 由 mozilla 开发并使用 apache 许可开源发布的工具库。其基于HTML5技术构建，用于展示可移植文档格式的文件(PDF)，它可以在现代浏览器中使用且无需安装任何第三方插件。简单的 demo 如下，详细使用方法可参考项目官网。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;pdf-canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">var url = &#x27;Helloworld.pdf&#x27;;</span><br><span class="line"></span><br><span class="line">PDFJS.getDocument(url).then((pdf) =&gt; &#123;</span><br><span class="line">    return pdf.getPage(1);</span><br><span class="line">&#125;).then((page) =&gt; &#123;</span><br><span class="line">    // 设置展示比例</span><br><span class="line">    var scale = 1.5;</span><br><span class="line">    // 获取pdf尺寸</span><br><span class="line">    var viewport = page.getViewport(scale);</span><br><span class="line">    // 获取需要渲染的元素</span><br><span class="line">    var canvas = document.getElementById(&#x27;pdf-canvas&#x27;);</span><br><span class="line">    var context = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="line">    canvas.height = viewport.height;</span><br><span class="line">    canvas.width = viewport.width;</span><br><span class="line">    </span><br><span class="line">    var renderContext = &#123;</span><br><span class="line">        canvasContext: context,</span><br><span class="line">        viewport: viewport</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    page.render(renderContext);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="通过在线预览服务"><a href="#通过在线预览服务" class="headerlink" title="通过在线预览服务"></a>通过在线预览服务</h3><p>微软和 Google 都提供了免费的文档在线预览服务，通过该服务我们可以非常方便的实便在 web 中预览文件，但是这种方式的缺点在于，文档必需为公网可访问，否则无法预览。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 微软 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&#x27;https://view.officeapps.live.com/op/view.aspx?src=http://a.com/b.xls&#x27;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">&#x27;100%&#x27;</span> <span class="attr">height</span>=<span class="string">&#x27;100%&#x27;</span> <span class="attr">frameborder</span>=<span class="string">&#x27;1&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Google --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">:src</span>=<span class="string">&quot;&#x27;https://docs.google.com/viewer?url=&quot;</span><span class="attr">fileurl</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了在公网使用微软服务，或将 word 或 excel 文件转为 PDF 外，还有没有其它的方式呢？</p><h2 id="sheet-js"><a href="#sheet-js" class="headerlink" title="sheet.js"></a>sheet.js</h2><p><a href="https://github.com/SheetJS/sheetjs">SheetJS</a> 和 pdf.js 类似，基于现在流行的 HTML5 技术构建，可以直接在web 页面中通过 js 或 ts 渲染表格。</p><h2 id="word-文件"><a href="#word-文件" class="headerlink" title="word 文件"></a>word 文件</h2><p>目前对于 word 文件还是无能为力。</p><h2 id="商业服务"><a href="#商业服务" class="headerlink" title="商业服务"></a>商业服务</h2><p>在企业市场，将文档转为共网可访问的文件，显然是不行的，因此催生了众多的商业服务为企业提供相关的解决方案。这里列举几个常见的平台：</p><ul><li>XDOC文档预览云服务 <a href="https://view.xdocin.com/">https://view.xdocin.com/</a>    支持私有化</li><li>永中 <a href="https://www.yozodcs.com/">https://www.yozodcs.com/</a>   支持私有化</li><li>IDOC <a href="https://www.idocv.com/docs.html">https://www.idocv.com/docs.html</a>  支持私有化</li><li>文档服务 DOC <a href="https://cloud.baidu.com/product/doc.html?track=cp:nsem%7Cpf:pc%7Cpp:doc%7Cpu:long%7Cci:%7Ckw:118945">https://cloud.baidu.com/product/doc.html?track=cp:nsem|pf:pc|pp:doc|pu:long|ci:|kw:118945</a></li><li>Wps <a href="https://wwo.wps.cn/docs/introduce/">https://wwo.wps.cn/docs/introduce/</a></li></ul><p>总结一下，对于可公开的文档，基于微软的在线预览服务，简单便捷。对于不可公开的文档，可以考虑将其转换为通用的 PDF 格式。如果有更多的要求，可以购买相关的服务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在一些中台系统中或管理后台系统中，在线预览 Office 文档是个比较常见的需求，奈何浏览器的支持有限在做相关功能时踩了一些坑。&lt;/p&gt;
&lt;h2 id=&quot;通用解决方案&quot;&gt;&lt;a href=&quot;#通用解决方案&quot; class=&quot;headerlink&quot; title=&quot;通用解决方案&quot;&gt;</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="前端" scheme="https://www.wewx.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>深入分析 MinIO Gateway 存储网关</title>
    <link href="https://www.wewx.cn/2022/05/10/minio-gateway.html"/>
    <id>https://www.wewx.cn/2022/05/10/minio-gateway.html</id>
    <published>2022-05-10T00:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>业务系统因文件存储需求，需新增通用文件服务，除公有云上使用，还要满足私用化场景，几番对比之最终选择基于 MinIO 构建，一来在公有上将其用作存储网关，在私有化环境中直接用作对象存储服务。</p><p>MinIO 是一个基于Apache License v2.0开源协议的对象存储服务。兼容 AWS S3 like API，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器&#x2F;虚拟机镜像等，而一个对象文件可以是任意大小，最大支持5T。</p><p>MinIO 除了是对象存储服务外，它还内置了一个存对网关 MinIO Gateway，后端支持多种 S3 like 类型的存储系统，像 S3、NAS、HDFS、Google Cloud对象存储等。</p><p>由于 MinIO 存储网关的存在，使用系统具备较好的兼容性和可移植性。在必要时，可以非常方便的从 S3 迁移到 Google Cloud  的对象存储，而不用调整系统，甚至是使用在后端同时使用多个厂商存储服务实现多云混合，再或者部署多个网关实现分布式以提供更为强大的并发能力。</p><p>MinIO 支持格式众多的云存储服务，不过在支持的产品列表中却没有我们常用的阿里云 OSS 或是腾讯云的储存服务，不得不说多少有些遗憾。</p><p>目前 MinIO 官网的支持清单：</p><ul><li>Azure</li><li>GCS</li><li>S3</li><li>HDFS</li></ul><h2 id="MinIO-Alibaba-OSS"><a href="#MinIO-Alibaba-OSS" class="headerlink" title="MinIO Alibaba OSS"></a>MinIO Alibaba OSS</h2><p>MinIO 在早期曾集成过 Alibaba OSS 的代理理服务，后因 Alibaba OSS 官方SDK 的 License 问题被 MinIO 移除。</p><p>时隔一年，虽 License 修复但重新申请合并的请求被拒绝了，此后 MinIO 官方也没有再支持国内主流厂商的计划。具体细节可查看 MinIO issue 中的相关讨论。</p><h2 id="MinIO-网关"><a href="#MinIO-网关" class="headerlink" title="MinIO 网关"></a>MinIO 网关</h2><p>MinIO 作为网关，主要有以下几个的功能。<br>首先，MinIO 网关能够屏蔽后台各存储产品的差异，便客户端提供统一的接口，使用 MinIO Clinent 即可在多种云之间切换。<br>其次，MinIO 网关能够向后端的云存储产品增加 MinIO 独有的一些功能，比如磁盘缓存、资源浏览器功能。<br>再次，通过部署多个网关，可实现分布的存储存架构，提升程序的可用性。</p><p>前面提到在现行的版本中，只是内置少量几个产品的Gateway，若要使用其他 OSS 或其或一些非 S3 like 的产品需要动手去扩展。</p><h3 id="Gateway的设计"><a href="#Gateway的设计" class="headerlink" title="Gateway的设计"></a>Gateway的设计</h3><p>Gateway 分为 GatewayLayer 和 ObjectLayer 及  Credential 2层。 GatewayLayer 包含网关名称和认证信息，而ObjectLayer 则是各对象存储的一个抽象。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h22cnt3q27j216q0i80tq.jpg"><br>￼￼<br>整个 MinIO Gateway 模块呈现一种分层的架构，如下图</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h22d5idcx6j20u010n76j.jpg"></p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>网关的接口其实比较简单的，就 2 个方法，获取名称和实例化 Object Layer.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gateway represents a gateway backend.</span></span><br><span class="line"><span class="keyword">type</span> Gateway <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Name returns the unique name of the gateway.</span></span><br><span class="line">Name() <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewGatewayLayer returns a new  ObjectLayer.</span></span><br><span class="line">NewGatewayLayer(creds madmin.Credentials) (ObjectLayer, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectLayer 接口由于是对象存储产品的抽象层，所以方法比较多，涵盖了 S3 like 的 Bucket 和 Object 的所有操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObjectLayer implements primitives for object API layer.</span></span><br><span class="line"><span class="keyword">type</span> ObjectLayer <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Locking operations on object.</span></span><br><span class="line">NewNSLock(bucket <span class="type">string</span>, objects ...<span class="type">string</span>) RWLocker</span><br><span class="line"></span><br><span class="line"><span class="comment">// Storage operations.</span></span><br><span class="line">Shutdown(context.Context) <span class="type">error</span></span><br><span class="line">NSScanner(ctx context.Context, bf *bloomFilter, updates <span class="keyword">chan</span>&lt;- DataUsageInfo, wantCycle <span class="type">uint32</span>, scanMode madmin.HealScanMode) <span class="type">error</span></span><br><span class="line">BackendInfo() madmin.BackendInfo</span><br><span class="line">StorageInfo(ctx context.Context) (StorageInfo, []<span class="type">error</span>)</span><br><span class="line">LocalStorageInfo(ctx context.Context) (StorageInfo, []<span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bucket operations.</span></span><br><span class="line">MakeBucketWithLocation(ctx context.Context, bucket <span class="type">string</span>, opts BucketOptions) <span class="type">error</span></span><br><span class="line">GetBucketInfo(ctx context.Context, bucket <span class="type">string</span>) (bucketInfo BucketInfo, err <span class="type">error</span>)</span><br><span class="line">ListBuckets(ctx context.Context) (buckets []BucketInfo, err <span class="type">error</span>)</span><br><span class="line">DeleteBucket(ctx context.Context, bucket <span class="type">string</span>, opts DeleteBucketOptions) <span class="type">error</span></span><br><span class="line">ListObjects(ctx context.Context, bucket, prefix, marker, delimiter <span class="type">string</span>, maxKeys <span class="type">int</span>) (result ListObjectsInfo, err <span class="type">error</span>)</span><br><span class="line">ListObjectsV2(ctx context.Context, bucket, prefix, continuationToken, delimiter <span class="type">string</span>, maxKeys <span class="type">int</span>, fetchOwner <span class="type">bool</span>, startAfter <span class="type">string</span>) (result ListObjectsV2Info, err <span class="type">error</span>)</span><br><span class="line">ListObjectVersions(ctx context.Context, bucket, prefix, marker, versionMarker, delimiter <span class="type">string</span>, maxKeys <span class="type">int</span>) (result ListObjectVersionsInfo, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">// Walk lists all objects including versions, delete markers.</span></span><br><span class="line">Walk(ctx context.Context, bucket, prefix <span class="type">string</span>, results <span class="keyword">chan</span>&lt;- ObjectInfo, opts ObjectOptions) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function MUST NOT return a non-nil ReadCloser.</span></span><br><span class="line">GetObjectNInfo(ctx context.Context, bucket, object <span class="type">string</span>, rs *HTTPRangeSpec, h http.Header, lockType LockType, opts ObjectOptions) (reader *GetObjectReader, err <span class="type">error</span>)</span><br><span class="line">GetObjectInfo(ctx context.Context, bucket, object <span class="type">string</span>, opts ObjectOptions) (objInfo ObjectInfo, err <span class="type">error</span>)</span><br><span class="line">PutObject(ctx context.Context, bucket, object <span class="type">string</span>, data *PutObjReader, opts ObjectOptions) (objInfo ObjectInfo, err <span class="type">error</span>)</span><br><span class="line">CopyObject(ctx context.Context, srcBucket, srcObject, destBucket, destObject <span class="type">string</span>, srcInfo ObjectInfo, srcOpts, dstOpts ObjectOptions) (objInfo ObjectInfo, err <span class="type">error</span>)</span><br><span class="line">DeleteObject(ctx context.Context, bucket, object <span class="type">string</span>, opts ObjectOptions) (ObjectInfo, <span class="type">error</span>)</span><br><span class="line">DeleteObjects(ctx context.Context, bucket <span class="type">string</span>, objects []ObjectToDelete, opts ObjectOptions) ([]DeletedObject, []<span class="type">error</span>)</span><br><span class="line">TransitionObject(ctx context.Context, bucket, object <span class="type">string</span>, opts ObjectOptions) <span class="type">error</span></span><br><span class="line">RestoreTransitionedObject(ctx context.Context, bucket, object <span class="type">string</span>, opts ObjectOptions) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multipart operations.</span></span><br><span class="line">ListMultipartUploads(ctx context.Context, bucket, prefix, keyMarker, uploadIDMarker, delimiter <span class="type">string</span>, maxUploads <span class="type">int</span>) (result ListMultipartsInfo, err <span class="type">error</span>)</span><br><span class="line">NewMultipartUpload(ctx context.Context, bucket, object <span class="type">string</span>, opts ObjectOptions) (uploadID <span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line">CopyObjectPart(ctx context.Context, srcBucket, srcObject, destBucket, destObject <span class="type">string</span>, uploadID <span class="type">string</span>, partID <span class="type">int</span>,</span><br><span class="line">startOffset <span class="type">int64</span>, length <span class="type">int64</span>, srcInfo ObjectInfo, srcOpts, dstOpts ObjectOptions) (info PartInfo, err <span class="type">error</span>)</span><br><span class="line">PutObjectPart(ctx context.Context, bucket, object, uploadID <span class="type">string</span>, partID <span class="type">int</span>, data *PutObjReader, opts ObjectOptions) (info PartInfo, err <span class="type">error</span>)</span><br><span class="line">GetMultipartInfo(ctx context.Context, bucket, object, uploadID <span class="type">string</span>, opts ObjectOptions) (info MultipartInfo, err <span class="type">error</span>)</span><br><span class="line">ListObjectParts(ctx context.Context, bucket, object, uploadID <span class="type">string</span>, partNumberMarker <span class="type">int</span>, maxParts <span class="type">int</span>, opts ObjectOptions) (result ListPartsInfo, err <span class="type">error</span>)</span><br><span class="line">AbortMultipartUpload(ctx context.Context, bucket, object, uploadID <span class="type">string</span>, opts ObjectOptions) <span class="type">error</span></span><br><span class="line">CompleteMultipartUpload(ctx context.Context, bucket, object, uploadID <span class="type">string</span>, uploadedParts []CompletePart, opts ObjectOptions) (objInfo ObjectInfo, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Policy operations</span></span><br><span class="line">SetBucketPolicy(context.Context, <span class="type">string</span>, *policy.Policy) <span class="type">error</span></span><br><span class="line">GetBucketPolicy(context.Context, <span class="type">string</span>) (*policy.Policy, <span class="type">error</span>)</span><br><span class="line">DeleteBucketPolicy(context.Context, <span class="type">string</span>) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Supported operations check</span></span><br><span class="line">IsNotificationSupported() <span class="type">bool</span></span><br><span class="line">IsListenSupported() <span class="type">bool</span></span><br><span class="line">IsEncryptionSupported() <span class="type">bool</span></span><br><span class="line">IsTaggingSupported() <span class="type">bool</span></span><br><span class="line">IsCompressionSupported() <span class="type">bool</span></span><br><span class="line">SetDriveCounts() []<span class="type">int</span> <span class="comment">// list of erasure stripe size for each pool in order.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Healing operations.</span></span><br><span class="line">HealFormat(ctx context.Context, dryRun <span class="type">bool</span>) (madmin.HealResultItem, <span class="type">error</span>)</span><br><span class="line">HealBucket(ctx context.Context, bucket <span class="type">string</span>, opts madmin.HealOpts) (madmin.HealResultItem, <span class="type">error</span>)</span><br><span class="line">HealObject(ctx context.Context, bucket, object, versionID <span class="type">string</span>, opts madmin.HealOpts) (madmin.HealResultItem, <span class="type">error</span>)</span><br><span class="line">HealObjects(ctx context.Context, bucket, prefix <span class="type">string</span>, opts madmin.HealOpts, fn HealObjectFn) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Backend related metrics</span></span><br><span class="line">GetMetrics(ctx context.Context) (*BackendMetrics, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns health of the backend</span></span><br><span class="line">Health(ctx context.Context, opts HealthOptions) HealthResult</span><br><span class="line">ReadHealth(ctx context.Context) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Metadata operations</span></span><br><span class="line">PutObjectMetadata(context.Context, <span class="type">string</span>, <span class="type">string</span>, ObjectOptions) (ObjectInfo, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectTagging operations</span></span><br><span class="line">PutObjectTags(context.Context, <span class="type">string</span>, <span class="type">string</span>, <span class="type">string</span>, ObjectOptions) (ObjectInfo, <span class="type">error</span>)</span><br><span class="line">GetObjectTags(context.Context, <span class="type">string</span>, <span class="type">string</span>, ObjectOptions) (*tags.Tags, <span class="type">error</span>)</span><br><span class="line">DeleteObjectTags(context.Context, <span class="type">string</span>, <span class="type">string</span>, ObjectOptions) (ObjectInfo, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Nas gateway 非常之简单： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NAS implements Gateway.</span></span><br><span class="line"><span class="keyword">type</span> NAS <span class="keyword">struct</span> &#123;</span><br><span class="line">path <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个 path 参数，但在 <code>NewGatewayLayer()</code> 中实例化了一个<code>FSObjects</code>，其结构是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FSObjects - Implements fs object layer.</span></span><br><span class="line"><span class="keyword">type</span> FSObjects <span class="keyword">struct</span> &#123;</span><br><span class="line">GatewayUnsupported</span><br><span class="line"></span><br><span class="line"><span class="comment">// Path to be exported over S3 API.</span></span><br><span class="line">fsPath <span class="type">string</span></span><br><span class="line"><span class="comment">// meta json filename, varies by fs / cache backend.</span></span><br><span class="line">metaJSONFile <span class="type">string</span></span><br><span class="line"><span class="comment">// Unique value to be used for all</span></span><br><span class="line"><span class="comment">// temporary transactions.</span></span><br><span class="line">fsUUID <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This value shouldn&#x27;t be touched, once initialized.</span></span><br><span class="line">fsFormatRlk *lock.RLockedFile <span class="comment">// Is a read lock on `format.json`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FS rw pool.</span></span><br><span class="line">rwPool *fsIOPool</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListObjects pool management.</span></span><br><span class="line">listPool *TreeWalkPool</span><br><span class="line"></span><br><span class="line">diskMount <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">appendFileMap   <span class="keyword">map</span>[<span class="type">string</span>]*fsAppendFile</span><br><span class="line">appendFileMapMu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// To manage the appendRoutine go-routines</span></span><br><span class="line">nsMutex *nsLockMap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，Nas 实际上是其于 MinIO 内置 <code>FSObjects</code> 来实现的。 <code>FSObjects</code> 是一种其于文件系统的网关，即使用本地文件系统来作为存储基础，这和 Nas 是一致的。</p><p>再来看 s3 gateway，相对来说就复杂得多。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> s3Objects <span class="keyword">struct</span> &#123;</span><br><span class="line">minio.GatewayUnsupported</span><br><span class="line">Client     *miniogo.Core</span><br><span class="line">HTTPClient *http.Client</span><br><span class="line">Metrics    *minio.BackendMetrics</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> s3Objects 通过 <code>NewGatewayLayer()</code> 实例化，参数是 s3 认证要素 Credentials，内部会实例化一个 <code>http.Transport</code>，后续所有操作都会使用该http 客户端访问 s3 api 完成相应的功能实现。</p><h3 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h3><h4 id="Gateway-启动过程"><a href="#Gateway-启动过程" class="headerlink" title="Gateway 启动过程"></a>Gateway 启动过程</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h234nd8mp2j21w40u0djj.jpg"><br>MinIO Gateway 是一个相关独立的系统，从命令行启动，具体的过程如上图。</p><p><code>main.go</code> 文件的中引入了 <code>cmd/gateway/</code> 这个包，<code>gateway</code> 包在<code>init</code> 过程中又引入了 <code>nas-gateway.go</code> 和 <code>s3-gateway.go</code> 。</p><p>这个 2 个就是系统默认附带的 NAS  网关 和 S3 网关的具体实现，它们在初始化时分别调用了 <code>cmd/gateway-main.go</code> 了 <code>RegisterGatewayCommand()</code> 方法，将自身注册成为 <code>gateway</code> 的子命令。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">minio.RegisterGatewayCommand(cli.Command&#123;</span><br><span class="line">Name:               minio.S3BackendGateway,</span><br><span class="line">Usage:              <span class="string">&quot;Amazon Simple Storage Service (S3)&quot;</span>,</span><br><span class="line">Action:             s3GatewayMain,</span><br><span class="line">CustomHelpTemplate: s3GatewayTemplate,</span><br><span class="line">HideHelpCommand:    <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所有网关初始化完成后，<code>main()</code> 函数执行。过程中调用 <code>cmd/main.go</code> 中 <code>Main()</code> ，同时会通过 <code>NewApp</code> 创建一个 app 实例，最后运行 app 实例的  run 方法执行命令功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewApp</span><span class="params">()</span></span> *App &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;App&#123;</span><br><span class="line">Name:         filepath.Base(os.Args[<span class="number">0</span>]),</span><br><span class="line">HelpName:     filepath.Base(os.Args[<span class="number">0</span>]),</span><br><span class="line">Usage:        <span class="string">&quot;A new cli application&quot;</span>,</span><br><span class="line">UsageText:    <span class="string">&quot;&quot;</span>,</span><br><span class="line">Version:      <span class="string">&quot;0.0.0&quot;</span>,</span><br><span class="line">BashComplete: DefaultAppComplete,</span><br><span class="line">Action:       helpCommand.Action,</span><br><span class="line">Compiled:     compileTime(),</span><br><span class="line">Writer:       os.Stdout,&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App 实例的初始化工作中包括 <code>gateway</code> 命令的注册。由于前面在 <code>init()</code>过程中已经将 <code>nas / s3</code> 的网关注册成为 <code>gateway</code> 的 <code>subCommands</code> ，因此 gateway 注册之后便 可以通过 <code>gateway s3</code> 子命令来启动 s3 网关。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterGatewayCommand</span><span class="params">(cmd cli.Command)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">cmd.Flags = <span class="built_in">append</span>(<span class="built_in">append</span>(cmd.Flags, ServerFlags...), GlobalFlags...)</span><br><span class="line">gatewayCmd.Subcommands = <span class="built_in">append</span>(gatewayCmd.Subcommands, cmd)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在完成所有命令注册之后，会根据输入参数调用对应的 Gateway 子命，基中调用 <code>StartGateway()</code> 完成整个 Gateway 启动。</p><h4 id="S3-Gateway-启动"><a href="#S3-Gateway-启动" class="headerlink" title="S3 Gateway 启动"></a>S3 Gateway 启动</h4><p>在注册 s3 Gateway 子命令到 Gateway 时需要传递一个 Action，即 子命令的入口程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">minio.RegisterGatewayCommand(cli.Command&#123;</span><br><span class="line">Name:               minio.S3BackendGateway,</span><br><span class="line">Usage:              <span class="string">&quot;Amazon Simple Storage Service (S3)&quot;</span>,</span><br><span class="line">Action:             s3GatewayMain,</span><br><span class="line">CustomHelpTemplate: s3GatewayTemplate,</span><br><span class="line">HideHelpCommand:    <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>s3GatewayMain()</code> 接受 Context 作接参数，在验证参数合法之后便会调用 <code>StartGateway()</code> 启动网关。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartGateway - handler for &#x27;minio gateway &lt;name&gt;&#x27;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartGateway</span><span class="params">(ctx *cli.Context, gw Gateway)</span></span> &#123;</span><br><span class="line"><span class="comment">// ... more code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>StartGateway</code> 程序比较复杂，在这里就不贴代码，仅详细分析一下启动过程中所进行的主要操作。</p><ul><li>Gateway 在启动之后是一个常驻进程，因此首先需要为其注册系统信号监听</li><li>初始化终端日志</li><li>初始化 Gateway 级别的全局 Locker</li><li>初始化系统配置，MinIO 使用的是自己实的配置解析系统。</li><li>在完成基础设置之后会初使化 Gateway router， 用以给客户端暴露一组接口</li><li>初使化管理功能路由（admin router ）</li><li>初使化健康检查功能路由（healthy check router ）</li><li>初使化 Metric router</li><li>使用 Credentials 调用 NewGatewayLayer 获对 ObjectLayer 实例</li><li>启动 IAM 子程序 （IAM sub-system）</li><li>启动 httpServer 监听客户端请求</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面从代码级别梳理了 Gateway 的设计，在了解 Gateway 原理和启动过程之后，我们为基添加默认没有支持的存储产品也就变得非常简单。</p><p>参考：</p><ul><li><a href="https://www.flysnow.org/2020/10/19/minio-gateway-sourcecode.html">从源代码级别看懂MinIO对象存储网关的实现</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;业务系统因文件存储需求，需新增通用文件服务，除公有云上使用，还要满足私用化场景，几番对比之最终选择基于 MinIO 构建，一来在公有上将其用作存储网关，在私有化环境中直接用作对象存储服务。&lt;/p&gt;
&lt;p&gt;MinIO 是一个基于Apache License v2.0开源协议的</summary>
      
    
    
    
    
    <category term="存储" scheme="https://www.wewx.cn/tags/%E5%AD%98%E5%82%A8/"/>
    
    <category term="MinIO" scheme="https://www.wewx.cn/tags/MinIO/"/>
    
  </entry>
  
  <entry>
    <title>取货自动结算无人售货机实现方案</title>
    <link href="https://www.wewx.cn/2022/05/03/rfid.html"/>
    <id>https://www.wewx.cn/2022/05/03/rfid.html</id>
    <published>2022-05-03T17:30:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>前天出门想要买水，刚好发现有无人自动售货机。是那种先取后付的机器，即扫码或刷脸开门、自助取货、关门后自动结算与扣款。买完东西后，走在路上想了想这种售货机的几种实现方案：</p><p><strong>摄像头识别与对比</strong><br>在每层置物架上面，安装超广角摄像头，在开门前对柜内每层架子上的商品拍照，关门再度拍照，通过对比差异推断顾客买的是哪种商品。</p><p>目前各个场商的图像实别算法都非常强大，该方案实现起来比较简单且成本较低，目前市场上大部分的先取后付无人售货机都是基于这种方案来实现。</p><p>但这个方案似乎衣有不足：假设有可乐和雪碧2种商品，都是300ml，但售价不一样，如果2种商品混合了，顶上的摄像头只能看到罐顶，其实是不能准确区分是可乐还是雪碧的。</p><p><strong>重量感应</strong></p><!-- 这个方案是来自一个小朋友的的想法。这个方案是否能实现精准推断顾客取出的商器呢? --><p>先来设想一下：<br>每层置物架上一般会分成多列放置不同的商品，每一列的底部分安装重量感应器，在开门前记录各列的重量数据，在关门重新计算，通过各列的数据比对推断取出的商品。这么看似乎可行。</p><p>但对于上面的混合了商品的场景，一样无法应对。</p><p><strong>红外线取出商品条码</strong><br>在售货机内部，在各个角度部属红外条码读码器，尝试360度读取取出商品的条码。</p><p>但也有一些问题：</p><ul><li>若条码刚好被遮挡，可能就不太好读码</li><li>只能识别拿动的端品条码，但无法区分动作的含义，比如：是拿出不是放入</li><li>成本可能会比较高吧</li></ul><p><strong>商品包装上放置芯片</strong><br>当时只是一种设想，即类似物联网的一物一码，在每个商品上都放一个小芯片来通信。</p><p>后面详细了解了一下，还真有这种成熟的解决方案，叫做 射频识别（Radio Frequency IDentification，RFID），应用领域非常广泛。</p><p>在优衣库等卖场自助收银台，顾客把衣服放到扫瞄框中，收银系统就能自动实别所要购买的商品，就是 rfid 的一种实际应用，据说 rfid iot 低频芯片成本可以做成几分钱。除了在收银台，还能用于库存盘点、一物一码、链路追踪等各个应用场景。</p><p>以上只是当时的一些小小想法，随着物联网和大数据时代的到来、人工智能的兴起，智能设备已环绕在我们衣食住行的各个方面，还真有些期待未来的智能社会能够早些到来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前天出门想要买水，刚好发现有无人自动售货机。是那种先取后付的机器，即扫码或刷脸开门、自助取货、关门后自动结算与扣款。买完东西后，走在路上想了想这种售货机的几种实现方案：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摄像头识别与对比&lt;/strong&gt;&lt;br&gt;在每层置物架上面，安装超广角摄像</summary>
      
    
    
    
    
    <category term="随见随想" scheme="https://www.wewx.cn/tags/%E9%9A%8F%E8%A7%81%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>原来是这样的 PKCS</title>
    <link href="https://www.wewx.cn/2022/05/01/pkcs.html"/>
    <id>https://www.wewx.cn/2022/05/01/pkcs.html</id>
    <published>2022-05-01T07:30:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>敏感数据加密在聚合支付系统中是硬性的要求，因此在系统中 RSA 加密无处不在。这几天在为系统开发 Java  SDK，由于是初学 Java，过程中的密钥转换、加解密、签名等颇有一番折腾。现在 SDK 开发已结整，今天抽点时间把与 RSA 相关的各种知识梳理一下。</p><h2 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h2><p>公开密钥基础建设 (Public key infrastructure)，又称公开密钥基础架构、公钥基础建设、公钥基础设施、公开密码匙基础建设或公钥基础架构，是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。 密码学上，公开密钥基础建设借着数字证书认证机构将用户的个人身份跟公开密钥链接在一起。</p><p>简单来说，它是在1976年提出的一套密码学理论，后来以 PIK为基础设计出了一系列的公开密钥算法，常用的 RSA、DSA等等。这些算也被称为非对称机密算法，一对密钥由公钥和私钥组成，公钥可以由私钥导出，但私钥不能由由公钥反向推导计算。在实际的使用中，私钥自己持有，公钥可以明文发式发送给别人，从而解决了密钥交换的问题。</p><p>除了密码学算法，从PKI基础上也发展出了一些安全协议，像互联网上广泛应用的 SSL 协议、SET协议等。</p><p>SSL 协议利用 PKI 技术来进行身份验证、完成数据加密算法及密钥交换，很好地解决了身份验证、加密传输和密钥分发等问题。</p><p>SET （Secure Electronic Transaction）安全电子交协议，主要采用公钥密码体系和X.509数字证书标准，用于保障网上购物信息的安全性。SET 协议是 PKI 框架下的一个典型实现，同时也在不断升级和完善，如 SET 2.0 将支持借记卡电子交易，在金融领域有着广泛的应用。</p><h2 id="XKMS"><a href="#XKMS" class="headerlink" title="XKMS"></a>XKMS</h2><p>由微软、VerSign和webMethods三家公司共同发布，全称是 XML 密钥管理规范，也被称为第二代PKI标准。<br>它由两部分组成：</p><ul><li>XML密钥信息服务规范</li><li>XML 密钥注册服务规范</li></ul><p>XKMS 目前已是W3C 推荐使用的标准，微软已在 ASP.net 中集成， VerSign也已发布了基于 Java 的信任服务集成开发工具包。</p><h2 id="CA中心"><a href="#CA中心" class="headerlink" title="CA中心"></a>CA中心</h2><p>数字证书认证机构（Certificate Authority，缩写为CA），也称为电子商务认证中心、电子商务认证授权机构，是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。</p><p>CA中心为每个使用公开密钥的用户发放一个数字证书，数字证书的作用是证明证书中列出的用户合法拥有证书中列出的公开密钥。CA机构的数字签名使得攻击者不能伪造和篡改证书。它负责产生、分配并管理所有参与网上交易的个体所需的数字证书，因此是安全电子交易的核心环节。在SET交易中，CA不仅对持卡人、商户发放证书，还要对获款的银行、网关发放证书。</p><p>CA是证书的签发机构，它是公钥基础设施的核心。CA是负责签发证书、认证证书、管理已颁发证书的机关。它要制定政策和具体步骤来验证、识别用户身份，并对用户证书进行签名，以确保证书持有者的身份和公钥的拥有权。</p><p>CA也拥有用户的证书（内含公钥）和私钥。网上的公众用户通过验证CA的签名从而信任CA，任何人都可以得到CA的证书（含公钥），用以验证CA所签发的证书。</p><p>用户若欲获取证书，应先向CA提出申请，CA判明申请者的身份后，为之分配一个公钥，并将该公钥与其身份信息绑定，为该整体签名，签名后的整体即为证书，发还给申请者。</p><p>如果一个用户想鉴别另一个证书的真伪，他就用CA的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。</p><p>为保证用户之间在网上传递信息的安全性、真实性、可靠性、完整性和不可抵赖性，不仅需要对用户的身份真实性进行验证，也需要有一个具有权威性、公正性、唯一性的机构，负责向电子商务的各个主体颁发并管理符合国际安全电子交易协议标准的电子商务安全证，并负责管理所有参与网上交易的个体所需的数字证书，因此CA是安全电子交易的核心环节。</p><p>在CA中心，普遍采的规范的是X.509和PKCS系列。</p><h2 id="X-509"><a href="#X-509" class="headerlink" title="X.509"></a>X.509</h2><p>X.509 是ITU-T标准化部门基于他们之前的ASN.1定义的一套公钥证书的格式标准。X.509证书里含有公钥、身份信息（比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构CA的签名，也可以是自签名）。</p><p>在X.509里，组织机构通过发起证书签名请求（CSR）来得到一份签名的证书。首先需要生成一对密钥对，然后用其中的私钥对CSR进行数字签署（签名），并安全地保存私钥。CSR进而包含有请求发起者的身份信息、用来对此请求进行验真的的公钥以及所请求证书专有名称。CSR里还可能带有CA要求的其它有关身份证明的信息。然后CA对这个CSR进行签名。 组织机构可以把受信的根证书分发给所有的成员，这样就可以使用公司的PKI系统了。浏览器（如Firefox）或操作系统预装有可信任的根证书列表，所以主流CA发布的TLS证书都直接可以正常使用。浏览器的开发者直接影响着它的用户对CA的信任。</p><h2 id="PKCS"><a href="#PKCS" class="headerlink" title="PKCS"></a>PKCS</h2><p>公钥加密标准（Public Key Cryptography Standards, PKCS），此一标准的设计与发布皆由RSA信息安全公司所制定。</p><p>PKCS 是一个系列集合，包含有15个标准。其中较常用的为 PKCS1、PKCS8、PKCS12</p><ul><li>PKCS1  RSA密码编译标准，定义了RSA的数理基础、公&#x2F;私钥格式，以及加&#x2F;解密、签&#x2F;验章的流程。</li><li>PKCS8 私钥消息表示标准，专门用来存储私钥的文件格式规范。</li><li>PKCS12 个人消息交换标准，定义了包含私钥与公钥证书（public key certificate）的文件格式。私钥采密码(password)保护。常见的PFX就履行了PKCS#12。</li></ul><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>RSA算法由 RSA公司发布，属于 PKCS系列的加密算法。同时它是我们在日常开发中用得最多的密码学算法。<br>从上面不难看出，RSA密码学的密钥对应着2个标准: PKCS1 和  PKCS8。这2个标准在定义上存在一些重合又不完全互通，但是可以利用工具在2种标准之间对密钥格式进行转换。</p><p><strong>PKCS1私钥转换为PKCS8</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -inform PEM -<span class="keyword">in</span> private.pem -outform pem -nocrypt -out pkcs8.pem</span><br></pre></td></tr></table></figure><p><strong>PKCS8格式私钥再转换为PKCS1格式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> pkcs8.pem -out pkcs1.pem</span><br></pre></td></tr></table></figure><p><strong>从PKCS1私钥中生成PKCS8公钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> private.pem -pubout -out public.pem</span><br></pre></td></tr></table></figure><p><strong>从PKCS8私钥中生成PKCS8公钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> pkcs8.pem -pubout -out public_pkcs8.pem</span><br></pre></td></tr></table></figure><p><strong>PKCS8公钥转PKCS1公钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -pubin -<span class="keyword">in</span> public_pkcs8.pem -RSAPublicKey_out</span><br></pre></td></tr></table></figure><p><strong>PKCS1公钥转换为PKCS8公钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -RSAPublicKey_in -<span class="keyword">in</span> pub_pkcs1.pem -pubout</span><br></pre></td></tr></table></figure><p><strong>小技巧</strong></p><ul><li><p>快速区分密钥</p><ul><li>PKCS8公钥格式  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">base64格式的公钥内容</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure></li><li>PKCS1 公钥格式  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PUBLIC KEY-----</span><br><span class="line"><span class="built_in">base64</span>格式的公钥内容</span><br><span class="line">-----END RSA PUBLIC KEY-----</span><br></pre></td></tr></table></figure></li><li>PKCS8 私钥格式  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGI PRIVATE KEY-----</span><br><span class="line"><span class="built_in">base64</span>格式的私钥内容</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure></li><li>PKCS1 私钥格式  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line"><span class="built_in">base64</span>格式的私钥内容</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在 Java 体系中，常用 PKCS8 格式的密钥</p></li><li><p>在其他编成语言中，一般常用 PKCS1 格式的密钥</p></li></ul><p>上一张体系图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1sxyo443mj21bz0u0wi3.jpg" alt="吹雨听风原创的PKI知体系图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;敏感数据加密在聚合支付系统中是硬性的要求，因此在系统中 RSA 加密无处不在。这几天在为系统开发 Java  SDK，由于是初学 Java，过程中的密钥转换、加解密、签名等颇有一番折腾。现在 SDK 开发已结整，今天抽点时间把与 RSA 相关的各种知识梳理一下。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="PKCS" scheme="https://www.wewx.cn/tags/PKCS/"/>
    
    <category term="PKI" scheme="https://www.wewx.cn/tags/PKI/"/>
    
    <category term="RSA" scheme="https://www.wewx.cn/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>这回是个 Java 小白</title>
    <link href="https://www.wewx.cn/2022/04/28/first-lesson-of-java.html"/>
    <id>https://www.wewx.cn/2022/04/28/first-lesson-of-java.html</id>
    <published>2022-04-28T16:40:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>Java 是个有20多年历史的编程语言，语言的生态和应用场景极其完善。尤其是在企业环境中有着非常官方的应用。</p><p>此前一直没有使用过 Java，对 java 并不是很，而现在马上需要给客户交付 Java 语言的支付 SDK，临时来报佛脚，边看边学边写SDK，过程着顺便做一些记录。</p><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><p>不过对于新手来说，首选面对的就是能排一长排的以 Java 为开头命名的名语，让人很是困惑：</p><ul><li><code>Java EE</code> Enterprise Edition。这个版本以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。</li><li><code>Java SE</code> Standard Edition。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。</li><li><code>Java ME</code> Micro Edition。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li><li><code>jre</code> 是Java的运行环境。面向Java程序的使用者，而不是开发者 。如果你仅下载并安装了JRE，那么你的系统只能运行Java程序。JRE是运行Java程序所必须环境的集合，包含JVM标准实现及Java核心类库。它包括Java虚拟机、Java平台核心类和支持文件。 它不包含开发工具(编译器、调试器等)。</li><li><code>jdk</code> JDK(Java Development Kit)又称J2SDK(Java2 Software Development Kit)，是Java开发工具包， 它提供了Java的开发环境(提供了编译器javac等工具，用于将java文件编译为class文件)和运行环境(提供了JVM和Runtime辅助包，用于解析class文件使其得到运行)。如果你下载并安装了JDK，那么你不仅可以开发Java程序，也同时拥有了运行Java程序的平台。 JDK是整个Java的核心，包括了Java运行环境(JRE)，一堆Java工具tools.jar和Java标准类库 (rt.jar)。</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1r10a12o9j20fk0b2t9r.jpg" alt="jre与jdk对比图"></p><p>除了上面的，还有一堆的令人困惑版本号：Java 1.x Java 1x。</p><blockquote><p>首先1996年发布了最初版本Java1.0，此后为Java1.1、J2SE1.2、J2SE1.3、J2SE1.4、采用 1.X的命名方式，直到 2004 年的 JavaOne 会议后版本数提升为 5.0，这一新版本为Java SE5.0，在 2006 年 Sun 公司终结了已经有 8 年历史的 J2SE、J2EE、J2ME 的命名方式启用了今天的 Java SE、Java EE、Java ME  命名方式，而此后的版本为 Java SE6、Java SE7、Java SE8、Java SE9、Java SE10、Java SE11、Java SE12、JAVA SE18</p></blockquote><blockquote><p>而JDK则在 Java1.0 到 Java9 对应每一个版本号 ：JDK1.0、JDK1.2 … JDK1.8、JDK1.9，Java10 以后JDK对应名称为：JDk10、JDK11、JDK12、JDK18</p></blockquote><p>所以</p><ul><li><code>Java 8</code> 指 Java SE 8.0 的版本</li><li><code>Java 18</code> 指 Java SE 18 的版本 </li><li><code>JDK 1.8</code> 则指 Java 8 对应的 JDK 版本</li></ul><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Java现在的最新版本是 Java 18，但在市场上最受欢迎的以及最为普遍的不是  <code>Java 8</code>，这又带来了环境与版本的问题。</p><p>但好在安装 Java 之后提供一个工具来管理当前系统上的java版本。命令是 <code>/usr/libexec/java_home</code> 。</p><p>在终端运行 <code>/usr/libexec/java_home -V</code> 可以看到系统中安装的所有版本的 Java  程序，并可以切换到对应的版本： <code>/usr/libexec/java_home -v &lt;version&gt;</code></p><p>如：<code>/usr/libexec/java_home -v 1.8</code>，可以切换到 JDK 1.8。之后可通过 <code>java -version</code> 来查看当前的版本。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>在 java 中有几个重要的环境变量需要在安装完 Java 之后进行配置：</p><ul><li><code>JAVA_HOME</code> 通常它指的是JDK的目录。如果需要JDK的话，大部分程序会默认去环境变量中取JAVA_HOME这个变量。</li><li><code>JRE_HOME</code> 同样，这也是一个约定的变量，通常指JRE目录。其实大部分Java程序不需要JDK，而是只需要其子集JRE，所以很多程序也会去取这个变量来用。</li></ul><p>在程序中，也可以通过 Java 提供的 API 来获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find <span class="type">String</span> <span class="variable">env</span> <span class="operator">=</span> System.getenv(<span class="string">&quot;PATH&quot;</span>);</span><br><span class="line">System.out.println(env);</span><br></pre></td></tr></table></figure><p>因此，我们可以将设置版本以及选设置环境变量放在 <code>~/.bash_profile</code> 或 <code>~/.zshrc</code> 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/libexec/java_home -v 1.8.0_331</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><h2 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h2><p>在 Java 程序中，有几种不同类型的文件后缀名，对应到程序的源码、编译等不同的阶段。</p><ul><li><code>.java</code> 是 Java 程序的源代码</li><li><code>.class</code> 是 .java 源代码编译的的字节码文件，真正可以被 jvm 执行</li><li><code>.jar</code> 将一组 .class 文件打包而来，本质是一个 zip 格式的压缩文件</li></ul><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>Apache Maven，是一个软件（特别是Java软件）项目管理及自动构建工具，由Apache软件基金会所提供。</p><p>Maven项目使用项目对象模型（Project Object Model，POM）来配置。</p><p>项目对象模型存储在名为 pom.xml 的文件中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java 是个有20多年历史的编程语言，语言的生态和应用场景极其完善。尤其是在企业环境中有着非常官方的应用。&lt;/p&gt;
&lt;p&gt;此前一直没有使用过 Java，对 java 并不是很，而现在马上需要给客户交付 Java 语言的支付 SDK，临时来报佛脚，边看边学边写SDK，过程着</summary>
      
    
    
    
    
    <category term="Java" scheme="https://www.wewx.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从扫码枪说明书看创业</title>
    <link href="https://www.wewx.cn/2022/04/24/thoughts-from-the-barcode-scanner-manual.html"/>
    <id>https://www.wewx.cn/2022/04/24/thoughts-from-the-barcode-scanner-manual.html</id>
    <published>2022-04-24T15:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>聚合支付系统第一个版本上线有些日子，第一个版本主打是线上支付，所有对于扫码的支付方式一直没有支持。</p><p>最近在对接某一开源商城系统，其中一个功能便是要支持线下支付，故而买了一个扫码枪用来测试扫码功能。</p><p>购买的时考虑到只是测试使用，直接买了最为便宜的一款，价格不到50元。产品收到，拆开包装盒，接上电脑便开始使用。第二日收拾盒子时发现里面有一本厚厚的书明书。当时我的第一感觉是这扫码枪全新只有一个按钮，对接条码按下按钮就能读取，这么简单的一个产品为啥需要这么厚的说明书，莫非还要设置不成，这本说明书里都讲些啥？</p><p>好奇之下翻了翻。翻开说明书才发现是我肤浅了！没错就是这么个拿手上按一下按钮就能用的小设备，说明书上大概有20种不同的配置！涵盖识读模式、延迟、出厂设置、结束符设置、扫描模式等等。不仅这么多配置的数量没想到，而且配置的方式也是之前没有想到的：厂家也把个配置项做成了条码，扫码产品本身扫一下就能完成设置。</p><p>设置是这么的简单，使用产品本身最大也是唯一的功能扫一扫，就能轻轻松松的实现自定义设置，不可谓不是大道至简。</p><p>相信扫码枪厂家也知道，这个产品大部分的买家都知道如何使用，甚至都不会看说明书，即使专业用户需要更改默认设置的也不多，即便如此，他们还是把产品做得很有深度。</p><p>同样，做为一个创业者，我们产品在满足大部分的常境规用户，还需要学习这种精益求精的精神，潜心打磨，在细节处，在后台，也要认真的去设计和对待，以满足普通用户之外的专业用户需要，从而赢得口碑。</p><p>我所理解的”极致”，就是在自己创业的领域，做到比绝大多数同行优秀一点，专注努力，步步为营，稳扎稳打。</p><p>突发的感慨，致自已，致伙伴，加油！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;聚合支付系统第一个版本上线有些日子，第一个版本主打是线上支付，所有对于扫码的支付方式一直没有支持。&lt;/p&gt;
&lt;p&gt;最近在对接某一开源商城系统，其中一个功能便是要支持线下支付，故而买了一个扫码枪用来测试扫码功能。&lt;/p&gt;
&lt;p&gt;购买的时考虑到只是测试使用，直接买了最为便宜的一</summary>
      
    
    
    
    
    <category term="创业" scheme="https://www.wewx.cn/tags/%E5%88%9B%E4%B8%9A/"/>
    
    <category term="感想" scheme="https://www.wewx.cn/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>给博客上了一款新主题 《snow white》</title>
    <link href="https://www.wewx.cn/2022/04/16/hexo-theme-snow-white.html"/>
    <id>https://www.wewx.cn/2022/04/16/hexo-theme-snow-white.html</id>
    <published>2022-04-16T00:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>使用 hexo 创建博客也有好几个年头了，可已写下的文章的不多，就一直是默认的主题挂在那儿。</p><p>今年以来立志要练习写作，也就打算好好的整一下这个静态博客，第一件事自然是得整个好看的、符合我极简审美的主题。耐何在 Hexo 主题站上找了一圈，也没有找到完全合意的主题，那就自己写一个。说干就开，于是之款起名叫《snow white》的主题诞生。</p><p>这是我开发的第一款主题，虽有些不足，但也有些特点。</p><h3 id="极致的简约"><a href="#极致的简约" class="headerlink" title="极致的简约"></a>极致的简约</h3><p>整体以白色设计为主，没有边边框框、背景色之类的装饰，自然更不会有 icon 和各种图标了。</p><h3 id="使用-Tailwind-css"><a href="#使用-Tailwind-css" class="headerlink" title="使用 Tailwind css"></a>使用 Tailwind css</h3><p>主题的风格样式完全使用 <a href="https://tailwindcss.com/">Tailwind css</a> 进行定义，编译后也仅仅只有 13kb。Tailwind css　是一个功能类优先的 CSS 框架，样式能够语义化，这样整体的布局、样式都更加清晰明了，方便进行二次开发和调整。</p><h3 id="中文排版"><a href="#中文排版" class="headerlink" title="中文排版"></a>中文排版</h3><p>中文排版一直是个比较头痛的问题了，为使文章易于阅读，在本主题中直接使用 <a href="https://typo.sofi.sh/">typo css</a> 进行文章正文的排版。　</p><h3 id="文章优化"><a href="#文章优化" class="headerlink" title="文章优化"></a>文章优化</h3><p>扩展了文章元数据，增加了</p><ul><li>相关文章</li><li>外部链接，可以申明本文的转载来源</li></ul><h3 id="seo-优化"><a href="#seo-优化" class="headerlink" title="seo 优化"></a>seo 优化</h3><p>扩展了页面和文章的 seo 元数据，支持为每篇文章或每个页面设置 seo 信息</p><ul><li>seo 描述　</li><li>seo 关键词　</li><li>seo title</li></ul><h3 id="深色模式"><a href="#深色模式" class="headerlink" title="深色模式"></a>深色模式</h3><p>暂未之前，后续再说。</p><h2 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a>主题下载</h2><p>从 github 下载<a href="https://github.com/cmzz/hexo-theme-snow-white">《snow white》</a>主题</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>在制作主题的过程中，参考了以下几款优秀主题：</p><ul><li><a href="https://d2fan.com/">https://d2fan.com/</a></li><li><a href="http://niexiaotao.cn/">http://niexiaotao.cn/</a></li><li><a href="https://typo.sofi.sh/">https://typo.sofi.sh/</a></li></ul>]]></content>
    
    
    <summary type="html">snow white 是 hexo 的一款极致简约的博客主题，纯白色调设计，无任何多余元素和图标，seo 支持友好，如果喜欢简约风格可以尝试</summary>
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>不同场景下的文件服务选型</title>
    <link href="https://www.wewx.cn/2022/02/23/file-service-selection.html"/>
    <id>https://www.wewx.cn/2022/02/23/file-service-selection.html</id>
    <published>2022-02-23T15:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>文件服务是一个非常基础的功能，一般来说，每个系统都会有类似上传头像、上传图片、上传办公文件等等类似的图片或文件上传功能。</p><p>每个项目的这部分功能其实是相似的，要说不同，也就是上传的文件类型不同，大小的限制不一样，访问的权限控制的力度不同，如果一个公司中有多个不同的项目，就非常有必要设计一个通用的文件服务来满足所有的类似的文件上传的功能。</p><p>在设计文件服务中，有以下几个关键属性需要我们考虑：</p><ul><li>文件内容的敏感程度</li><li>文件平均大小</li><li>文件的使用方式、使用频率</li><li>文件的访问控制</li><li>文件的重要程度</li></ul><p>上面列举的文件属性都是从文件本身和使用方面考虑的，属性的不同决定着必须采取不同的方式来对待：</p><h4 id="文件内容的敏感程度"><a href="#文件内容的敏感程度" class="headerlink" title="文件内容的敏感程度"></a>文件内容的敏感程度</h4><p>什么是内容的敏感程度？敏感数据主要包括个人隐私信息、密码&#x2F;密钥、敏感图片等高价值数据。用大白话来说就是上传的这个文件，在上传者匿名的情况下，文件的内容会不会暴露上传者或其他人&#x2F;事物&#x2F;公司的敏感信息。例如，在金融或支付之类的系统中，文件中包含银行卡号码、电话号码、用户身份证号码，或是企业的合同等等，包含这类信息的文件就可以说是敏感文件。反之像是用户随手发到博客的图片，即使被人无意中看到也没关系，这就不敏感。</p><p>在我们设计文件服务服务的时候，如果需要存储敏感文件，那么就要充分的考虑文件内容的保密性。可以采取的常见措施为：</p><p><strong>敏感数据识别</strong>：接接收到用户上传的数据时，能够有相应的算法实别到该文件属于较为敏感的数据，以便在存储时加以区别对待。</p><p><strong>分块存储</strong>：即将文件切为很多个块。放在不同的地方，即使得到一块也无法还原文件内容。</p><p><strong>加密存储</strong>：在文件写入到磁盘保存之前，对文件字节进行加密。如果当年冠希哥懂点安全的话，那观众就少了一个大瓜。</p><p><strong>混淆存储</strong>：保存文件的时候，用一定的规则将文件内容打乱重排，窃取或看到的人也就看不懂了，从而起到保护文件中机密的作用</p><p><strong>同城冗余存储</strong>：在同一个城市的多个分区数据中心对文件保存多份副本。当某个可用区不可用时，仍然能够保障数据的正常访问。</p><p><strong>跨区域复制</strong>：跨越多个不同的地域数据中心之间复制数据，让重要数据一次保存到多个城市，从而实现更高的可用性。</p><h4 id="文件平均大小"><a href="#文件平均大小" class="headerlink" title="文件平均大小"></a>文件平均大小</h4><p>文件的体积决定着文件的访问和存储的效率。那是不是小文件相对于大文件是不是在读取速度、保存的写入速度等各方面都要快呢？并不是的。 </p><p>在淘宝系统中，由于商品图片、装修图片、描述图片都属于小图片，系统中就存在海量的小文件，或是在机器学习中，同样的也会用到大量的小文件。对于这些海量的小文件，如果采用常规的存储和访问方式，效率将会极其低下。反过来，大量的大文件也存在相应的问题，于是在这样的背景下，就诞生了各种不同的文件存储系统来适配不同的场景，如：小文件适用的 TFS，大文件适用的 GridFS，还有 HDFS、FastDFS 等等，这里就不做展开了。整理了一些参考，如下。</p><p><strong>小文件存储</strong>：</p><ul><li><a href="https://blog.51cto.com/u_14977574/2547854">支撑 Bilibili 的小文件存储系统</a></li></ul><p><strong>大文件存储</strong>：</p><ul><li><a href="https://support.huaweicloud.com/topic/182577-1-D">大文件存储系统</a></li></ul><h4 id="使用方式和频率"><a href="#使用方式和频率" class="headerlink" title="使用方式和频率"></a>使用方式和频率</h4><p>保存的文件的访问方式和访问频率通常由使用场景决定，在实际中，我们需要根据工作的负载和访问模式来确定最佳的存储方案。</p><p><strong>归档存储</strong>：因其价格低廉、通常为离线冷数据存储，非常适合海量、非结构化数据长时间备份。<br><strong>低频访问</strong>：低频访问存储价于标准化的存储和归档存存之间，支持数据实时访问，适用于较低访问频率（平均每月访问频率1到2次）的业务场景。</p><h4 id="文件的访问控制"><a href="#文件的访问控制" class="headerlink" title="文件的访问控制"></a>文件的访问控制</h4><p>文件是否能公开访问？能否授权给其他人访问？组织内的其他人否访问？</p><p>通常情况下，在设计文件服务时，除了默认只有资源拥有者或者被授权的用户允许访问外，还应支持用户授权他人访问或使用自己的上传的文件资源，需要考虑权限控制策略以解决向他人授予特定权限的问题。</p><h4 id="重要程度"><a href="#重要程度" class="headerlink" title="重要程度"></a>重要程度</h4><p>在现在信息化社会中，数据和文件就是最为重要的资产，如果要保存重要的文件，意味着在存储和使用的过程中需要做好充分的防丢失、防止损坏的措施。应对丢失最常见的方式就是异地、多城、多云同步备份，保持多份文案拷贝，此外文件版本控制机制也能比较好的防止文件意外损坏。</p><p>最后，现在处于一个云时代，在实际的工作实践中，我们在做文件系统的设计选型时，通常会考虑在底层使用云存储，例如各平台的对象存储服务（OSS）。那么此时在价格因素之外，还要充分的评估云产品的特性能否匹配到我们系统的使用场景和要求，系统评估后再做决策。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文件服务是一个非常基础的功能，一般来说，每个系统都会有类似上传头像、上传图片、上传办公文件等等类似的图片或文件上传功能。&lt;/p&gt;
&lt;p&gt;每个项目的这部分功能其实是相似的，要说不同，也就是上传的文件类型不同，大小的限制不一样，访问的权限控制的力度不同，如果一个公司中有多个不同</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="存储" scheme="https://www.wewx.cn/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker 网络模式不完全指南</title>
    <link href="https://www.wewx.cn/2018/10/10/docker-network-mode-not-complete-guide.html"/>
    <id>https://www.wewx.cn/2018/10/10/docker-network-mode-not-complete-guide.html</id>
    <published>2018-10-10T00:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>本次分享没有：</p><ul><li>Docker的背景</li><li>Docker的整体架构</li><li>Docker的核心实现技术</li><li>Docker的高级用法</li><li>Docker的使用秘笈</li></ul><p>本次分享是：<br><em>Docker使用中的…</em><br><em>一条命令的…</em><br><em>一个参数的..</em><br><em>不完全说明.</em></p><h3 id="Docker网络模式"><a href="#Docker网络模式" class="headerlink" title="Docker网络模式"></a>Docker网络模式</h3><p>一般文章中说的网络模式，其实主要是指 <code>docker run</code> 命令的 <code>--net</code> 或 <code>--network</code> 参数所支持的模式，默认包括：</p><ol><li>bridge模式（划重点，最后说）<br> 使用 <code>--network=bridge</code> 指定，默认设置可不指定</li><li>host模式<br> 使用 <code>--network=host</code> 指定</li><li>container模式<br> 使用 <code>--network=container:NAME_or_ID</code> 指定</li><li>none模式<br> 使用 <code>--network=none</code> 指定</li></ol><p>有时网络模式也会包括其他的模式，例如 <a href="https://docs.docker.com/network/macvlan/">macvlan</a>、<a href="https://docs.docker.com/network/overlay/">overlay</a> 等，这些并不仅通过上述参数指定，属于高级用法，如有需要可查阅文档。<br>这里只介绍常见的上述4种模式。</p><h4 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h4><p>容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</p><ul><li>试验<br>创建容器：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -d --network host --name my_nginx nginx</span><br></pre></td></tr></table></figure>在宿主机检查端口监听情况：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -tulpn | grep :80</span><br></pre></td></tr></table></figure></li></ul><p>通过这种模式，一些命令行工具可以很方便地通过docker来使用，避免在宿主机安装大量的依赖包，也便于随时清理。例如启动一个 tcpdump 的容器抓取主机上的网络报文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=host -v $PWD:/data corfr/tcpdump -i any -w /data/dump.pcap &quot;icmp&quot;</span><br></pre></td></tr></table></figure><h4 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h4><p>在了解了 host 模式后，这个模式也就好理解了。这个模式创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。<br>kubernetes 的 pod 可以认为就是用这个实现的（？），同一个 pod 中的容器共享一个 network namespace。</p><ul><li>试验<br>我们运行两个 nginx 容器：web1 和 web2：<br>web1 监听在 80 端口，使用默认的网络模型<br>web2 监听在 8080 端口，使用 container 网络模型共享 web1 的网络<br>先启动 web1，通过端口映射把端口绑定到主机上：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=web1 -p 80:80 nginx</span><br></pre></td></tr></table></figure>使用 curl 命令验证容器运行正常：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:80</span><br></pre></td></tr></table></figure>第二个容器和 host 模式相同，使用 –net 参数让新建的容器使用 web1 的网络：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=web2 -v $&#123;PWD&#125;/default.conf:/etc/nginx/sites-available/default -v $&#123;PWD&#125;/index.html:/var/www/html/index.html -d --net=container:web1 nginx</span><br></pre></td></tr></table></figure>其中 <code>default.conf</code> 文件就是修改了 nginx 默认配置文件的端口，把它变成 8080；<code>inedx.html</code> 可以随便修改一点，以区别于默认的内容。<br>在 web1 或 web2 容器里面可以验证 nginx 服务：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8080</span><br></pre></td></tr></table></figure>在两个容器中，可以分别通过 <code>ip addr</code> 查看网络配置，是完全一致的（命令和执行结果从略）。</li></ul><h4 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h4><p>这个模式和前两个不同。在这种模式下，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。<br>选择这种模式，一般是用户对网络有自己特殊的需求，不希望 docker 预设置太多的东西。</p><h4 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h4><p>在默认的bridge模式下，docker 会在宿主机上新创建一个网桥，可以把它想象成一个虚拟的交换机，所有的容器都是连到这台交换机上面的。docker 会从私有网络中选择一段地址来管理容器，比如 172.17.0.1&#x2F;16（这个地址根据你之前的网络情况而有所不同）。通过网桥，让容器的子网可以访问宿主机所连接的外网，并且可以通过 <strong>端口映射</strong> 来实现容器对外暴露端口提供服务（即外部可以通过宿主机、网桥访问容器上的服务）。这是最常用的网络模式，又分为以下两种情况：</p><ol><li>使用默认网络</li></ol><p>默认的网络docker将其称为 <code>bridge</code> 网络，在这种情况下，容器可以相互通信（若出于安全考虑，也可以禁止它们之间通信，方法是在 <code>DOCKER_OPTS</code> 变量中设置 <code>--icc=false</code>，这样只有使用 <code>--link</code> 选项才能使两个容器通信，关于 <code>--link</code> 后面还会说到）。<br>容器可以访问外部网络，但是Docker容器的IP、网络等对外是不可见的。即外部服务发现的访问客户端IP，是宿主机IP而不是容器IP。<br>而通过端口映射，可以让外部访问Docker容器的服务。</p><ul><li>试验<br>我们首先用下面命令创建一个含有 web 应用的容器，将容器的 80 端口映射到主机的 80 端口。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -d --name web -p 80:80 nginx</span><br></pre></td></tr></table></figure></li></ul><p>如果宿主机的IP为10.10.101.105，外界只需访问10.10.101.105:80 就可以访问到容器中的服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://10.10.101.105:80</span><br></pre></td></tr></table></figure><p>查看默认的网络</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect bridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;aeeabedfaa07ae4d06d0dad4ede4126a93e0efd9a2a5f0034551665aa2744976&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-29T03:25:10.046595598Z&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;1a30155cb661730fe5733a20ca8f692da0ce9edae1932b902399ed31e4b42cbd&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;web&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;2d2009eb67cd56b9a40bea4d43be87d45fd61994a85e27fd0546494d065cfd3b&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="2"><li>自行创建网络</li></ol><p>这种情况与使用默认网络基本类似，只是通过命令创建自有的网络和网桥来实现通信，这样就可以自己规划网络拓扑。在建立开发环境时，这是很常用的一种方式。laradock 即采用这种方式。</p><ul><li>试验<br>创建一个名为 <code>web-net</code> 的自定义网络，使用bridge网络驱动：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge web-net</span><br></pre></td></tr></table></figure></li></ul><p>查看一下已经创建的网络列表，可以看到除了docker自行创建的 <code>bridge</code> 网络，还有刚创建的 <code>web-net</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p>查看 <code>web-net</code> 网络的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect web-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;web-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;79be842fea854d32708498bb01bf67e3b4967ffe32405493be2f1c6424eb4752&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-29T06:57:23.58969899Z&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>创建两个容器，使用 <code>web-net</code> 网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -d --name web1 --network web-net nginx</span><br><span class="line">docker run --rm -d --name web2 --network web-net nginx</span><br></pre></td></tr></table></figure><p>再次查看 <code>web-net</code> 网络的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect web-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;web-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;79be842fea854d32708498bb01bf67e3b4967ffe32405493be2f1c6424eb4752&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-29T06:57:23.58969899Z&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;614b91e2000356945a1aba29cfa4dacad04f0bf254972c78a54aacd3663079ca&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;web1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;d0254e60f67f6d5eb155731bb028c40a2b723b0ef2aacfbe641b96dd67ca5a75&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;6aa947097ca8b6189c7a057b545ff718a82b15df4212cad6ee1ce3f2031e4bb5&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;web2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;9be085bf7f3d075f4224b285d7a3c4c382b516c22698a151c1049ea9298ee567&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可见容器 <code>web1</code> 和 <code>web2</code> 已经加入了此网络，并且分配了各自的网络IP，并使用同一个网络和网关。</p><h4 id="bridge模式下默认网络和自建网络的差别"><a href="#bridge模式下默认网络和自建网络的差别" class="headerlink" title="bridge模式下默认网络和自建网络的差别"></a>bridge模式下默认网络和自建网络的差别</h4><ol><li>提供更好的网络隔离和更灵活的拓扑</li></ol><p>这一点不言而喻，只是需了解：各容器的全部端口，对当前网络（不论是默认还是自建）内的其他容器完全开放，而对宿主机和外界都不开放，除非设置端口映射。</p><ol start="2"><li>自建网络自动提供了各容器名称的DNS解析</li></ol><p>默认网络下，各容器只能通过IP访问，除非显式设置 <a href="https://docs.docker.com/network/links/">–link 选项</a><br>而在自建网络中，默认就可以在某个容器中通过容器的名称来访问其他容器。</p><ol start="3"><li><p>容器可以动态的（无需重启容器）加入自建网络或移除（通过 <code>docker network connect</code> 或 <code>docker network disconnect</code> ，而如果要加入或移除默认网络，需要重建容器。</p></li><li><p>每个自建网络拥有自己的可配置的网桥，可以进行更灵活的网桥参数配置。</p></li><li><p>在默认网络并通过 <code>--link</code> 选项连接的容器可以共享环境变量，但在自建网络中不行。</p></li></ol><h3 id="Docker实现"><a href="#Docker实现" class="headerlink" title="Docker实现"></a>Docker实现</h3><p>Docker的网络模式实际上是基于网络驱动来实现的，要了解网络驱动，需要先了解Docker的网络模型架构。<br>Docker的网络架构基于称为 <strong>容器网络模型 Container Networking Model (CNM)</strong> 的一组接口来实现：</p><p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485228_49.png" alt="图片描述"></p><p>图中以Docker Engine为界，上半部分（高层网络设施）是下半部分（驱动）的处理实例。</p><p>CNM与网络驱动的结构和关系：</p><p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485279_69.png" alt="图片描述"></p><p>另外还需了解的是：Docker 使用了 Linux 的 <a href="https://coolshell.cn/articles/17010.html">Namespaces</a> 技术来进行资源隔离，如 PID Namespace 隔离进程，Mount Namespace 隔离文件系统，Network Namespace 隔离网络等。一个 Network Namespace 提供了一份独立的网络环境，包括网卡、路由、Iptable 规则等都与其他的 Network Namespace 隔离。</p><ol><li>Host驱动<br>  在Host驱动模式下，docker 不会为容器创建单独的网络 namespace，而是共享主机的 network namespace，也就是说：容器可以直接访问主机上所有的网络信息。</li></ol><p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485300_42.png" alt="图片描述"></p><ol><li>Bridge驱动（默认网络）<br>  在Bridge驱动模式下，如果不自行建立网络（ <code>docker network create ...</code> ），会直接使用docker自建的默认网络。docker会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</li></ol><p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485329_29.png" alt="图片描述"></p><p>Docker 完成以上网络配置的过程大致是这样的：<br>在主机上创建一对虚拟网卡 veth pair 设备。veth 设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth 设备常用来连接两个网络设备。Docker 将 veth pair 设备的一端放在新创建的容器中，并命名为 eth0。另一端放在主机中，以 veth65f9 这样类似的名字命名，并将这个网络设备加入到 docker0 网桥中，可以通过 brctl show 命令查看。</p><p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485347_11.png" alt="图片描述"></p><p>从 docker0 子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的默认网关。</p><ol start="3"><li>Bridge驱动（自建网络）</li></ol><p><img src="/tfl/captures/2019-02/tapd_64812569_base64_1550485354_79.png" alt="图片描述"></p><p>与默认网络的区别在于，自行创建了网桥和一个或多个子网。</p><ol start="4"><li>Overlay、MACVLAN、None从略，如需了解请查阅 <a href="https://success.docker.com/article/networking">官方文档</a></li></ol><p>一些细节说明：</p><ol><li>host&#x2F;bridge模式分别基于Host&#x2F;Bridge驱动实现，这很好理解。那么container模式呢？</li></ol><p>实际上container模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，因此可以认为是使用“别人”的驱动来实现。</p><ol start="2"><li>在bridge模式下，docker通过Iptable来实现容器对外是不可见。docker是如何实现的？</li></ol><p>通过宿主机的 iptables 的 <strong>SNAT</strong> 转换。<br>查看包含bridge模式容器的宿主机上的 iptables 规则，可以看到这么一条规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>这条规则会将源地址为 172.17.0.0&#x2F;16 的包（也就是从 Docker 容器产生的包），并且不是从 docker0 网卡发出的，进行源地址转换，转换成主机网卡的地址。<br>举例说明：假设主机有一块网卡为 eth0，IP 地址为 10.10.101.105&#x2F;24，网关为 10.10.101.254。从主机上一个 IP 为 172.17.0.1&#x2F;16 的容器中 ping 百度（180.76.3.151）。IP 包首先从容器发往自己的默认网关 docker0，包到达 docker0 后，也就到达了主机上。然后会查询主机的路由表，发现包应该从主机的 eth0 发往主机的网关 10.10.105.254&#x2F;24。接着包会转发给 eth0，并从 eth0 发出去（主机的 ip_forward 转发应该已经打开）。这时候，上面的 Iptable 规则就会起作用，对包做 SNAT 转换，将源地址换为 eth0 的地址。这样在外界看来，这个包就是从 10.10.101.105 上发出来的</p><ol start="3"><li>docker如何实现端口映射？</li></ol><p>通过宿主机的 iptables 的 <strong>DNAT</strong> 转换。<br>在进行端口映射之后，查看宿主机的 iptables 规则的变化，发现多了这样一条规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A DOCKER ! -i docker0 -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.17.0.5:80</span><br></pre></td></tr></table></figure><p>此条规则就是对主机 eth0 收到的目的端口为 80 的 tcp 流量进行 DNAT 转换，将流量发往 172.17.0.5:80，也就是我们上面创建的 Docker 容器。所以，外界只需访问 10.10.101.105:80 就可以访问到容器中得服务。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>容器如何连接和使用宿主机上的服务？</li></ol><p>从上面的内容可以看出，如果可以的话，使用 <code>Host</code> 网络模式，是最方便的，容器里随便怎么连宿主机都毫无成本。<br>其实，即使是 <code>bridge</code> 模式，容器本来也是连接到宿主机的，唯一的一点点障碍，仅仅是宿主机的IP可能是动态的，同时也没有天然的DNS名对应宿主机（其实在Windows、MAC环境有这样的DNS名称，有需要可以查看 host.docker.internal <a href="https://docs.docker.com/docker-for-windows/networking/#i-cannot-ping-my-containers">for windows</a> <a href="https://docs.docker.com/docker-for-mac/networking/#i-cannot-ping-my-containers">for mac</a>）。<br>通过以下方式之一可以在 <code>bridge</code> 模式 找到宿主机的IP：</p><ul><li><p>如果使用默认网络，在宿主机上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr show docker0 | grep inet</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">    inet6 fe80::42:62ff:fefa:e57c/64 scope link</span><br></pre></td></tr></table></figure><p>其中 <code>172.17.0.1</code> 便是默认网络在宿主机上的IP</p></li><li><p>如果使用自建网络，在宿主机上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect &#123;你的自建网络名称&#125; | grep Gateway</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.19.0.1&quot;</span><br></pre></td></tr></table></figure><p>其中 <code>172.19.0.1</code> 便是默认网络在宿主机上的IP。<br>其实这种方式也适用于在默认网络情况，将网络名称改为 <code>bridge</code> 即可。</p></li><li><p>在容器中更加简单，执行 <code>ip route show</code> 或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hostip=$(ip route show | awk &#x27;/default/ &#123;print $3&#125;&#x27;)</span><br><span class="line">$ echo $hostip</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>ifconfig</code> 或 <code>ip addr</code> 获取到宿主机的eth0或外网IP，也是可以的，只是略微有一点性能损失。例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostip=`ip -4 addr show scope global dev eth0 | grep inet | awk &#x27;&#123;print \$2&#125;&#x27; | cut -d / -f 1`</span><br><span class="line">$ echo $hostip</span><br></pre></td></tr></table></figure></li></ul><p>获取到IP之后，还需注意：<br>a. 宿主机需要允许被连接，一般情况应该是可以的，如果不行需要设置 <code>iptables -A INPUT -i docker0 -j ACCEPT</code> 。<br>b. 宿主机上的服务应该监听在 0.0.0.0 或 * （即 <code>INADDR_ANY</code>），可以通过 <code>lsof -i | grep 端口号XXXX</code> 查看。</p><p>另外，为了在容器中更方便的连接宿主机，可以通过传入Host的方式来自行设置一个DNS名称，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ HOSTIP=`ip -4 addr show scope global dev eth0 | grep inet | awk &#x27;&#123;print \$2&#125;&#x27; | cut -d / -f 1`</span><br><span class="line">$ docker run  --add-host=docker:$&#123;HOSTIP&#125; --rm -it debian</span><br></pre></td></tr></table></figure><p>在 <code>docker-compose</code> 中则可以通过 <code>extra_hosts</code> 来达到同样的效果，laradock就是通过这样的方式（需要在 .env 中指定 <code>DOCKER_HOST_IP</code> 变量为宿主机IP。</p><ol start="2"><li>一个承载了多个服务API的容器，每个API服务对应不同域名，如果让这些服务更加友好地相互访问？<br>  考虑多个项目共用一个laradock场景，nginx服承载了多个服务API，并对外提供统一的服务端口。而各个服务API的域名和nginx配置设计上是不同的，并存在相互依赖关系。某个服务想使用另一个服务的API时，要求使用默认的主机名域名（nginx）可能造成API路由冲突，各自nginx配置也不方便。如何做到对各个不同域名API的访问都指向同一个nginx容器？<br>  有多种办法解决这个问题，但最简单的，是通过 <code>--net-alias</code> 参数，或者是 docker-compose 的  <code>networks:网络XXX:aliases:</code>，例如在 laradock 的 <code>docker-compose.yml</code> 中有：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nginx:</span><br><span class="line">  ...</span><br><span class="line">  networks:</span><br><span class="line">    frontend:</span><br><span class="line">    backend:</span><br><span class="line">      aliases:</span><br><span class="line">        - account-system.dd01.test</span><br><span class="line">        - account-base-service.dd01.test</span><br><span class="line">        - member-notification-service.dd01.test</span><br><span class="line">        - points-core-system.dd01.test</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>这样就可以通过这里所列出的域名来访问各个服务，由nginx配置来根据域名（ <code>server_name</code>配置 ）分别对应到具体的服务项目。</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://docs.docker.com/network/">https://docs.docker.com/network/</a><br><a href="https://success.docker.com/article/networking">https://success.docker.com/article/networking</a> (深入了解推荐)<br><a href="https://docs.docker.com/engine/reference/run/#network-settings">https://docs.docker.com/engine/reference/run/#network-settings</a><br><a href="https://www.infoq.cn/article/docker-network-and-pipework-open-source-explanation-practice">https://www.infoq.cn/article/docker-network-and-pipework-open-source-explanation-practice</a><br><a href="http://cizixs.com/2016/06/01/docker-default-network/">http://cizixs.com/2016/06/01/docker-default-network/</a><br><a href="https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container">https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次分享没有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker的背景&lt;/li&gt;
&lt;li&gt;Docker的整体架构&lt;/li&gt;
&lt;li&gt;Docker的核心实现技术&lt;/li&gt;
&lt;li&gt;Docker的高级用法&lt;/li&gt;
&lt;li&gt;Docker的使用秘笈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次分享是：</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Docker" scheme="https://www.wewx.cn/tags/Docker/"/>
    
    <category term="HTTPS" scheme="https://www.wewx.cn/tags/HTTPS/"/>
    
    <category term="网络" scheme="https://www.wewx.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Docker 端口的 expose 与 publish</title>
    <link href="https://www.wewx.cn/2018/08/24/docker-expose-publish.html"/>
    <id>https://www.wewx.cn/2018/08/24/docker-expose-publish.html</id>
    <published>2018-08-24T02:36:48.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Dockerfile</code> 里通过 <code>Expose</code> 导出一个 <code>80</code> 的端口:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><p>启动容器后,发现还是无法本机的 <code>80</code> 端口访问容器内服务。只有在启动时通过 <code>-p</code> 参数publish 端口才可以，像下面这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 demo</span><br></pre></td></tr></table></figure><p>这是为啥呢?<br>都已经在 <code>Dockerfile</code> 里面 <code>Expose</code> 为啥还不能直接访问?</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>使用下面4中不同的方法启动容器:</p><ul><li>不在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，也不通过 <code>-p</code> 参数指定</li><li>在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，但不使用 <code>-p</code> 参数</li><li>在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，也使用 <code>-p</code> 参数</li><li>只使用 <code>-p</code> 参数</li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><ul><li>第一中情况: 不能在外网访问，也不能被 link 的 container 访问</li><li>第二种情况: 不能被外网访问，但是能被 link 的 container 访问</li><li>第三种情况: 能被外网访问，也能被 link 容器访问</li><li>第四中情况: 和第三种情况一样</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>EXPOSE</code> 只是导出端口。只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。<br>在 <code>Dockerfile</code> 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>通过 <code>docker ps</code> 命令，可以看到，端口的映射关系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 &lt;code&gt;Dockerfile&lt;/code&gt; 里通过 &lt;code&gt;Expose&lt;/code&gt; 导出一个 &lt;code&gt;80&lt;/code&gt; 的端口:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Docker" scheme="https://www.wewx.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 网络之端口映射不完全探索</title>
    <link href="https://www.wewx.cn/2018/07/20/docker-network-port-mapping.html"/>
    <id>https://www.wewx.cn/2018/07/20/docker-network-port-mapping.html</id>
    <published>2018-07-20T00:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章实在团队内部的分享，如下：</p><p>今天的分享不包含故事背景、docker的发展与应用…</p><p>分享源于对问题 ‘我已经在　Dockerfile 中通过 EXPOSE 指定了端口为何任然无法访问？’ 深入探索。其实今天的分享也可以视为对上一期峰哥分享的一个补充。</p><p>Docker容器的端口映射</p><blockquote><p>容器的服务端口绑定到宿主机的端口上。效果就是：外部程序通过宿主机的P端口访问，就像直接访问 Docker 容器网络内部容器提供的服务一样。</p></blockquote><p>今天的分享主要涉及到的 Docker run 命令，参数如下：</p><ul><li>-p&#x2F;-P</li><li>–expose</li></ul><h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>expose 参数有两种使用形式：</p><ul><li>在 <code>docker run</code> 命令时指定 <code>--expose</code> 参数, 如 –expose&#x3D;8080</li><li>在 Dockerfile 中，通过 <code>EXPOSE</code> 关键字</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><blockquote><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口。</p></blockquote><p><strong>注意</strong>：</p><p>仅仅是申明。并不是说你声明了这个端口，在运行容器的时候就会自动的暴露这个端口。使用时，还要依赖于容器的操作人员进一步指定网络规则。</p><p>本质上来说， <code>EXPOSE</code> 或者 <code>--expose</code> 只是为其他命令提供所需信息的元数据，或者只是告诉容器操作人员有哪些已知选择。</p><p>验证：　通过　<code>docker run nginx</code> 启动一个容器, 然后通过　｀docker inspect id&#96;　查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;HostConfig&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;PortBindings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;443/tcp&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;80/tcp&quot;</span>: null</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到端口被标示成已暴露，但是没有定义任何与主机的端口映射。</p><h4 id="p-x2F-P"><a href="#p-x2F-P" class="headerlink" title="-p&#x2F;-P"></a>-p&#x2F;-P</h4><p><code>-p</code> 与 <code>-P</code>　参数的完整形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-p, --publish list </span><br><span class="line">-P, --publish-all </span><br></pre></td></tr></table></figure><p>这两个参数都是发布端口到宿主主机。但用法上存在一点区别。</p><p><code>-p</code> 显式将一个或者一组端口从容器里绑定到宿主机上。<br><code>-P</code> 自动的将EXPOSE指令相关的每个端口映射到宿主机的端口上。</p><p>-p 参数常见的用法是: <code>-p 宿主主机端口:容器端口</code>。　如果使用　｀docker run -p 8080:80 nginx&#96; 命令启动nginx 容器，那么容器中的 80端口会绑定到主机的8080端口。</p><p>这是，我们再通过　<code>docker inspect id</code> 来查看，将会看到下面的绑定关系:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;HostConfig&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;PortBindings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;443/tcp&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;80/tcp&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;HostIp&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;HostPort&quot;</span>: <span class="string">&quot;8080&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为没有指定443端口的绑定，所以能看到仅有 80端口和宿主机存在端口映射关系。</p><p>另外，在使用-p参数是，我们可以忽略指定宿主主机端口。这是，docker会帮助我们自动的选择一个合适端口和容器端口进行绑定。这样做的好处是在启动多个容器时可以避免端口冲突。</p><p>例如上面的启动命令可以改为 <code>docker run -p 80 nginx</code>,　这时如果我们本机的80端口被占用，docker就会自动的选择一个其他端口。我们可以通过 <code>docker ps</code> 或 <code>docker inspect</code>　命令来查看端口的映射关系。</p><p>-P 参数用法: <code>docker run -P nginx</code>.<br>-P 参数须配合　Dockerfile  一起使用，　能够将 Expose 声明的端口映射到宿主主机。</p><p>此时，使用 <code>docker inspect </code>命令，可以看到 dockerfile 中申明的端口都已经绑定到了主机上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;HostConfig&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;PortBindings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;443/tcp&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;HostIp&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;HostPort&quot;</span>: <span class="string">&quot;443&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">        <span class="string">&quot;80/tcp&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;HostIp&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;HostPort&quot;</span>: <span class="string">&quot;80&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="expose-和-p-功能对比"><a href="#expose-和-p-功能对比" class="headerlink" title="-expose 和 -p 功能对比"></a>-expose 和 -p 功能对比</h4><p>我们可以通过如下的实验来更好的理解两参数之间的区别。</p><ul><li>不在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，也不通过 <code>-p</code> 参数指定</li><li>在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，但不使用 <code>-p</code> 参数</li><li>在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，也使用 <code>-p</code> 参数</li><li>在 <code>Dockerfile</code> 里 <code>EXPOSE</code>，也使用 <code>-P</code> 参数</li><li>只使用 <code>-p</code> 参数</li></ul><p><strong>结果</strong></p><ul><li>第一中情况: 不能在外网访问，也不能被 link 的 container 访问</li><li>第二种情况: 不能被外网访问，但是能被 link 的 container 访问</li><li>第三种情况: 能被外网访问，也能被 link 容器访问iw</li><li>第四种情况: 和第三种情况一样</li><li>第五种情况: 和第三种情况一样</li></ul><h3 id="Docker-端口映射原理"><a href="#Docker-端口映射原理" class="headerlink" title="Docker 端口映射原理"></a>Docker 端口映射原理</h3><p><strong>备注：</strong> 这一块挺乱的，我也没弄得很清楚，权当抛砖引玉了。</p><p>原本我理解端口映射是这样的一个通信过程：</p><ul><li>Docker进程启动的时候，会在宿主主机创建路由，同时创建docker0网桥</li><li>容器启动的时候创建 vethxx　的网卡，同时链接到网桥</li><li>通过 -p 参数指定端口映射后，　创建iptables规则</li><li>当有流量通过宿主主机端口进来用，通过iptables 匹配到规则后，转换为容器对应的子网ip</li><li>主机的路由指定了 172.xx　网段的ip由 docker0 处理</li><li>docker0再将请求转发到子网中容器</li></ul><p>后面和朋友了解了，发现还有　docker-proxy 的存在，于是，上面的理解是其实就片面的，不完善的。</p><hr><p>到现在，关于 Docker 端口映射的实现一共有2方案.</p><ul><li>1.7版本之前 docker-proxy + iptables DNAT 的方式<br>即，内网访问通过 iptables<br>外网访问通过 proxy</li><li>1.7版本之后的 iptables DNAT<br>完全由　iptables 实现</li></ul><p>Docker 1.7版本起，Docker提供了一个配置项： -userland-proxy，以让　Docker　用户决定是否启用　docker-proxy，默认为true，即启用docker-proxy。<br>现在的　Docker　环境默认的是： -userland-proxy&#x3D;true。iptables　和　docker-proxy　都会起作用。</p><p><strong>-userland-proxy&#x3D;true的情况下</strong></p><p>在启用 docker-proxy 的情况下。每设置一对端口映射就会启动一个 docker-proxy 进程。</p><p>可以通过 ps 命令查看 docker-proxy　进程信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep docker-proxy</span><br><span class="line"></span><br><span class="line">root      5532 19713  0 2月20 ?       00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 443 -container-ip 172.19.0.8 -container-port 443</span><br><span class="line">root      5546 19713  0 2月20 ?       00:00:01 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 80 -container-ip 172.19.0.8 -container-port 80</span><br></pre></td></tr></table></figure><p>通过 sudo netstat -nltpu 查看本机的端口监听情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      5546/docker-proxy          </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      5532/docker-proxy</span><br></pre></td></tr></table></figure><p>通过上面的命令，会发现，我们映射到宿主机的端口被　docker-proxy　进程监听了。</p><p>别急，我们再看一下iptables，发现其中增加了对应的规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"> sudo iptables-save -t nat                 </span><br><span class="line"># Generated by iptables-save v1.6.1 on Fri Feb 22 15:06:17 2019</span><br><span class="line">*nat</span><br><span class="line">:PREROUTING ACCEPT [55751:14743102]</span><br><span class="line">:INPUT ACCEPT [55615:14734886]</span><br><span class="line">:OUTPUT ACCEPT [260072:22717364]</span><br><span class="line">:POSTROUTING ACCEPT [260200:22725044]</span><br><span class="line">:DOCKER - [0:0]</span><br><span class="line">-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER</span><br><span class="line">-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER</span><br><span class="line">-A POSTROUTING -s 172.20.0.0/16 ! -o br-bf4c59b26d33 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.0/16 ! -o br-e2ab1d51063d -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.18.0.0/16 ! -o br-c9af812dc067 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.2/32 -d 172.19.0.2/32 -p tcp -m tcp --dport 6379 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.3/32 -d 172.19.0.3/32 -p tcp -m tcp --dport 27017 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.5/32 -d 172.19.0.5/32 -p tcp -m tcp --dport 3306 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.6/32 -d 172.19.0.6/32 -p tcp -m tcp --dport 9501 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.6/32 -d 172.19.0.6/32 -p tcp sudo iptables -t filter -L</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DOCKER-USER  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-1  all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain DOCKER (4 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.2           tcp dpt:6379</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.3           tcp dpt:27017</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.5           tcp dpt:mysql</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.6           tcp dpt:9501</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.6           tcp dpt:ssh</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.8           tcp dpt:https</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.8           tcp dpt:http</span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-1 (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">RETURN     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-2 (4 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">RETURN     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain DOCKER-USER (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">RETURN     all  --  anywhere             anywhere -m tcp --dport 22 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.8/32 -d 172.19.0.8/32 -p tcp -m tcp --dport 443 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.19.0.8/32 -d 172.19.0.8/32 -p tcp -m tcp --dport 80 -j MASQUERADE</span><br><span class="line">-A DOCKER -i br-bf4c59b26d33 -j RETURN</span><br><span class="line">-A DOCKER -i br-e2ab1d51063d -j RETURN</span><br><span class="line">-A DOCKER -i br-c9af812dc067 -j RETURN</span><br><span class="line">-A DOCKER -i docker0 -j RETURN</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 6379 -j DNAT --to-destination 172.19.0.2:6379</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 27017 -j DNAT --to-destination 172.19.0.3:27017</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 3306 -j DNAT --to-destination 172.19.0.5:3306</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 9501 -j DNAT --to-destination 172.19.0.6:9501</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 2222 -j DNAT --to-destination 172.19.0.6:22</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 443 -j DNAT --to-destination 172.19.0.8:443</span><br><span class="line">-A DOCKER ! -i br-e2ab1d51063d -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.19.0.8:80</span><br></pre></td></tr></table></figure><p>这里的 <code>DOCKER</code> 对应的是由 docker　自定义的一组过滤规则，可以通过　<code>sudo iptables -t filter -L</code>　查看到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t filter -L</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DOCKER-USER  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-1  all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain DOCKER (4 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.2           tcp dpt:6379</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.3           tcp dpt:27017</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.5           tcp dpt:mysql</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.6           tcp dpt:9501</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.6           tcp dpt:ssh</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.8           tcp dpt:https</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.19.0.8           tcp dpt:http</span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-1 (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere            </span><br><span class="line">RETURN     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-2 (4 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line">RETURN     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain DOCKER-USER (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">RETURN     all  --  anywhere             anywhere </span><br></pre></td></tr></table></figure><p><strong>-userland-proxy&#x3D;false的情况下</strong></p><p>待研究~</p><p><strong>性能</strong></p><p>docker-proxy 在网络上吐槽的比较多，因为每一对端口映射都会对一个 docker-proxy进程，如果端口较多，可能就会带来性能问题。且在单个 docker-proxy 的情况下，性能比 iptables 略差。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>－ –link 能够访问　expose 声明的端口</p><ul><li>-expose 仅声明端口，并不会自动映射到宿主主机</li><li>-p 指定端口映射关系</li><li>-P 将 expose 声明的端口发布到宿主主机</li><li>在处理端口映射是，iptables　规则优先，如果没有匹配到iptables规则，则由 docker-proxy处理</li></ul><p><strong>待深入研究的问题：</strong></p><ul><li>container &lt;-&gt; container、host &lt;-&gt; container、 container &lt;-&gt; host　各自怎么选择策略的</li><li>iptables 规则</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章实在团队内部的分享，如下：&lt;/p&gt;
&lt;p&gt;今天的分享不包含故事背景、docker的发展与应用…&lt;/p&gt;
&lt;p&gt;分享源于对问题 ‘我已经在　Dockerfile 中通过 EXPOSE 指定了端口为何任然无法访问？’ 深入探索。其实今天的分享也可以视为对上一期峰哥分享的</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Docker" scheme="https://www.wewx.cn/tags/Docker/"/>
    
    <category term="容器" scheme="https://www.wewx.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>PHP 的编码规范</title>
    <link href="https://www.wewx.cn/2018/07/18/php-standard.html"/>
    <id>https://www.wewx.cn/2018/07/18/php-standard.html</id>
    <published>2018-07-18T02:36:48.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>版本：v1.0<br>日期：2018-10-10</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>为了更好的提高技术部的工作效率，保证开发的有效性和合理性，并可最大程度的提高程序代码的可读性和可重复利用性，指定此规范。</p><h3 id="整体要求"><a href="#整体要求" class="headerlink" title="整体要求"></a>整体要求</h3><p>本规范以 <a href="https://www.php-fig.org/psr/psr-2/">PSR2</a> 规范为基础制定,是 <a href="https://www.php-fig.org/psr/psr-2/">PSR2</a> 规范的继承与扩展。</p><p>新项目需完全遵守本规范，之前旧系统代码可以可以继续遵守原有的规范。</p><h3 id="「能愿动词」的使用"><a href="#「能愿动词」的使用" class="headerlink" title="「能愿动词」的使用"></a>「能愿动词」的使用</h3><p>为了避免歧义，文档大量使用了「能愿动词」(<a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>)，对应的解释如下：</p><ul><li>必须 (MUST)：绝对，严格遵循，请照做，无条件遵守；</li><li>一定不可 (MUST NOT)：禁令，严令禁止；</li><li>应该 (SHOULD) ：强烈建议这样做，但是不强求；</li><li>不该 (SHOULD NOT)：强烈不建议这样做，但是不强求；</li></ul><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="1-关于-PHP-版本选择"><a href="#1-关于-PHP-版本选择" class="headerlink" title="1. 关于 PHP 版本选择"></a>1. 关于 PHP 版本选择</h3><ul><li><strong>必须</strong> 使用 <code>PHP 7.0</code> 以上的版本。</li><li><strong>应该</strong> 使用最新的稳定版本。</li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>源文件 <strong>必须</strong> 只使用 <code>&lt;?php</code>。</li><li>源文件中 PHP 代码的编码格式 <strong>必须</strong> 只使用 <code>不带 BOM 的 UTF-8</code>。</li><li>源文件在文件结尾处 <strong>必须</strong> 忽略掉 <code>?&gt;</code> 且 <strong>必须</strong> 以一个空行结尾。</li><li>类定义文件 <strong>必须</strong> 使用类名作为文件名, 用首字母大写。</li><li>类文件 <strong>必须</strong> 使用命名空间为路径存储。</li><li>除类文件外，其他文件全部用小写字母加下划线命名。</li></ul><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ul><li>源文件中 <strong>必须</strong> 声明为严格模式 <code>declare(strict_types=1);</code>。</li><li><strong>必须</strong> 为类方法和函数声明参数类类型、返回值类型。</li><li>一个类方法和函数 <strong>必须</strong> 只有一种类型的返回参数。</li></ul><h3 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h3><ul><li>一个源文件 <strong>应该</strong> 只用来做声明（类，函数，常量等）或者只用来做一些辅助作用的操作（例如：输出信息，修改 .ini 配置等），但不应当同时做这两件事。</li><li>类名 <strong>必须</strong> 使用 <code>StudlyCaps</code> 写法,比如 <code>SampleController</code>。</li><li>类中的常量 <strong>必须</strong> 只由大写字母和下划线(_)组成。</li><li>方法名 <strong>必须</strong> 使用 <code>camelCase（驼峰式)</code> 写法，比如 <code>getTotalById</code>。</li><li>变量名 <strong>必须</strong> 使用 <code>camelCase（驼峰式)</code> 写法。</li><li>代码 <strong>必须</strong> 使用 4 个空格符进行缩进。<br>  备注: 使用空格而不是 <code>tab</code> 键 缩进的好处在于，避免在比较代码差异、打补丁、重阅代码以及注释时产生混淆。并且，使用空格缩进，让对齐变得更方便。</li><li>关键字 以及 <code>true</code> &#x2F; <code>false</code> &#x2F; <code>null</code><br>  PHP 所有关键字 <strong>必须</strong> 全部小写。<br>  常量 <code>true</code> 、<code>false</code> 和 <code>null</code> 也必须全部小写。</li><li>运算符(<code>=, +, -, *, /, %, +=</code>等等)左右两边 <strong>必须要有</strong> 一个空格。</li><li><strong>应该</strong> 使用 <code>===</code> 运算符代替 <code>==</code> 运算符，应该使用 <code>true</code> &#x2F; <code>false</code> 常来代替 <code>1</code> &#x2F; <code>0</code>。</li><li>每行 <strong>一定不可</strong> 有多条语句。</li><li>非空行后 <strong>一定不可</strong> 有多余的空格。</li><li>运算表达式可以在运算符处换行，且运算符应 <strong>该放</strong> 在下一行的开始。</li><li>缩写词（含专有名词）与其他词组合命名， <strong>必须</strong> 使用 <code>camelCase（驼峰式)</code> 写法，如： <code>ApiUrl</code>。</li></ul><h3 id="行-与-空行"><a href="#行-与-空行" class="headerlink" title="行 与 空行"></a>行 与 空行</h3><ul><li>每行的字符数 <strong>应该</strong> 保持在 80 个以内， 通常情况 <strong>不该</strong> 超过 120 个。如果换行可能破坏语意或降低可阅读性，可作为例外超出限制。</li><li>代码块开始之前与结束符 <code>&#125;</code> 之后，<strong>应该</strong> 有一个空行。</li><li>方法和函数的 <code>return</code> 语句之前，<strong>应该</strong> 有一个空行。</li><li>完成一定功能的代码块前后，<strong>应该</strong> 各有一个空行。</li><li><strong>一定不可</strong> 存在连续的 2 个以上的空行。</li></ul><h3 id="类、Interface、Trait"><a href="#类、Interface、Trait" class="headerlink" title="类、Interface、Trait"></a>类、Interface、Trait</h3><ul><li><p>每个 <code>namespace</code> 命名空间声明语句和 <code>use</code> 声明语句块后面，必须插入一个空白行。所有 <code>use</code> <strong>必须</strong> 在 <code>namespace</code> 后声明。每条 <code>use</code> 声明语句 <strong>必须</strong> 只有一个 <code>use</code> 关键词。<code>use</code> 声明语句块后 <strong>必须</strong> 要有一个空白行。例如：</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">FooClass</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">BarClass</span> <span class="keyword">as</span> <span class="title">Bar</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OtherVendor</span>\<span class="title">OtherPackage</span>\<span class="title">BazClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... additional PHP code ...</span></span><br></pre></td></tr></table></figure></li><li><p>扩展与继承，关键词 <code>extends</code> 和 <code>implements</code>  <strong>必须</strong> 写在类名称的同一行，类的开始花括号 <strong>必须</strong> 独占一行，结束花括号也 <strong>必须</strong> 在类主体后独占一行。例如:</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">FooClass</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">BarClass</span> <span class="keyword">as</span> <span class="title">Bar</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OtherVendor</span>\<span class="title">OtherPackage</span>\<span class="title">BazClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> <span class="keyword">implements</span> <span class="title">ArrayAccess</span>, <span class="title">Countable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// constants, properties, methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>implements</code> 的继承列表也可以分成多行，这样的话，每个继承接口名称都 <strong>必须</strong> 分开独立成行，包括第一个。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">FooClass</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">BarClass</span> <span class="keyword">as</span> <span class="title">Bar</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OtherVendor</span>\<span class="title">OtherPackage</span>\<span class="title">BazClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">ArrayAccess</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Countable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// constants, properties, methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的开始花括号(<code>&#123;</code>) <strong>必须</strong> 写在函数声明后自成一行，结束花括号(<code>&#125;</code>)也 <strong>必须</strong> 写在函数主体后自成一行。</p></li><li><p>方法的开始花括号(<code>&#123;</code>) <strong>必须</strong> 写在函数声明后自成一行，结束花括号(<code>&#125;</code>) <strong>也必须</strong> 写在函数主体后自成一行。<br>  一个标准的方法声明可参照以下范例，留意其括号、逗号、空格以及花括号的位置。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fooBarBaz</span>(<span class="params"><span class="variable">$arg1</span>, &amp;<span class="variable">$arg2</span>, <span class="variable">$arg3</span> = []</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的属性和方法必须添加访问修饰符（<code>private</code>、<code>protected</code> 以及 <code>public</code>）， <code>abstract</code> 以及 <code>final</code> 必须声明在访问修饰符之前，而 <code>static</code> <strong>必须</strong> 声明在访问修饰符之后。<br>  以下是属性声明的一个范例：</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$foo</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  需要添加 <code>abstract</code> 或 <code>final</code> 声明时， <strong>必须</strong> 写在访问修饰符前，而 <code>static</code> 则 <strong>必须</strong> 写在其后。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">static</span> <span class="variable">$foo</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">zim</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的属性和方法 <strong>一定不可</strong> 使用 <code>_</code> 开头命名来区分私有方法。</p></li><li><p>方法的参数声明过多时，每个参数可以独占一行</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReturnTypeVariations</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">anotherFunction</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">string</span> <span class="variable">$foo</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">string</span> <span class="variable">$bar</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> <span class="variable">$baz</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类方法与函数"><a href="#类方法与函数" class="headerlink" title="类方法与函数"></a>类方法与函数</h3><ul><li><p>参数和变量列表中逗号(，)前 <strong>必须不能有</strong> 空格，而逗号后 <strong>必须要有</strong> 空格。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"><span class="variable">$arg1</span>, &amp;<span class="variable">$arg2</span>, <span class="variable">$arg3</span> = []</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参数列表可以分列成多行，这样，包括第一个参数在内的每个参数都 <strong>必须</strong> 单独成行。<br>  拆分成多行的参数列表后，结束括号以及方法开始花括号 <strong>必须</strong> 写在同一行，中间用一个空格分隔。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">aVeryLongMethodName</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        ClassTypeHint <span class="variable">$arg1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        &amp;<span class="variable">$arg2</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">array</span> <span class="variable">$arg3</span> = []</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法及函数调用时，方法名或函数名与参数左括号之间 <strong>一定不可</strong> 有空格，参数右括号前也 <strong>一定不可</strong> 有空格。每个参数前 <strong>一定不可</strong> 有空格，但参数 <code>，</code> 之后 <strong>必须</strong> 有一个空格。</p></li></ul><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><ul><li><p>控制结构的基本规范如下</p><ul><li>控制结构的关键字后 <strong>必须</strong> 要有一个空格符，而调用方法或函数时则一定不能有。</li><li>控制结构的开始花括号(<code>&#123;</code>) <strong>必须</strong> 写在声明的同一行，而结束花括号(<code>&#125;</code>)必须写在主体后自成一行。</li><li>控制结构的开始左括号后和结束右括号前，都 <strong>一定不可</strong> 有空格符。</li></ul></li><li><p><code>case</code> 语句 <strong>必须</strong> 相对 <code>switch</code> 进行一次缩进，而 <code>break</code> 语句以及 <code>case</code> 内的其它语句都 <strong>必须</strong> 相对 <code>case</code> 进行一次缩进。<br>如果存在非空的 <code>case</code> 直穿语句，主体里 <strong>必须</strong> 有类似 <code>// no break</code> 的注释。例如:</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="variable">$expr</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;First case, with a break&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Second case, which falls through&#x27;</span>;</span><br><span class="line">        <span class="comment">// no break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Third case, return instead of break&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Default case&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>应该</strong> 使用关键词 <code>elseif</code> 代替所有 <code>else if</code>，以使得所有的控制关键字都像是单独的一个词。例如:</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$expr1</span>) &#123;</span><br><span class="line">    <span class="comment">// if body</span></span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="variable">$expr2</span>) &#123;</span><br><span class="line">    <span class="comment">// elseif body</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// else body;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>while 和 do while。一个规范的 while 语句 <strong>应该</strong> 如下所示，注意其 括号、空格以及花括号的位置。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$expr</span>) &#123;</span><br><span class="line">    <span class="comment">// structure body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>标准的 <code>do while</code> 语句如下所示，同样的，注意其 括号、空格以及花括号的位置。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// structure body;</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="variable">$expr</span>);</span><br></pre></td></tr></table></figure></li><li><p>标准的 <code>for</code> 语句如下所示，注意其括号、空格以及花括号的位置。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">10</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="comment">// for body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>标准的 <code>foreach</code> 语句如下所示，注意其括号、空格以及花括号的位置。例如:</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$iterable</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="comment">// foreach body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>标准的 <code>try catch</code> 语句如下所示，注意其括号、空格以及花括号的位置。例如:</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// try body</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FirstExceptionType <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="comment">// catch body</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (OtherExceptionType <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="comment">// catch body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li><p>闭包声明时，关键词 <code>function</code> 后以及关键词 <code>use</code> 的前后都必须要有一个空格。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$closureWithArgs</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$arg1</span>, <span class="variable">$arg2</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$closureWithArgsAndVars</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$arg1</span>, <span class="variable">$arg2</span></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$var1</span>, <span class="variable">$var2</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$closureWithArgsVarsAndReturn</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$arg1</span>, <span class="variable">$arg2</span></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$var1</span>, <span class="variable">$var2</span></span>): <span class="title">bool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$longArgs_longVars</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="variable">$longArgument</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="variable">$longerArgument</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="variable">$muchLongerArgument</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) <span class="keyword">use</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="variable">$longVar1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="variable">$longerVar2</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="variable">$muchLongerVar3</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$foo</span>-&gt;<span class="title function_ invoke__">bar</span>(</span><br><span class="line">    <span class="variable">$arg1</span>,</span><br><span class="line">    function (<span class="variable">$arg2</span>) <span class="keyword">use</span> ($<span class="title">var1</span>) &#123;</span><br><span class="line">        // <span class="title">body</span></span><br><span class="line">    &#125;,</span><br><span class="line">    $<span class="title">arg3</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>开始花括号 <strong>必须</strong> 写在声明的同一行，结束花括号 <strong>必须</strong> 紧跟主体结束的下一行。</p></li><li><p>同事遵守 <code>函数</code> 和 <code>类方法</code> 的相关原则。</p></li></ul><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><ul><li><p>匿名类 <strong>必须</strong> 遵守 <code>闭包</code> 和 <code>类</code> 的相关原则。</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$instance</span> = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> \<span class="title">Foo</span> <span class="keyword">implements</span> \<span class="title">HandleableInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Class content</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$instance</span> = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> \<span class="title">Foo</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    \<span class="title">ArrayAccess</span>,</span></span><br><span class="line"><span class="class">    \<span class="title">Countable</span>,</span></span><br><span class="line"><span class="class">    \<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Class content</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><p>文件头部注释 (可选)</p><ul><li><code>author</code>： 作者以及联系邮箱。</li><li><code>createTime</code>：文件创建时间 - 可以通过git来追踪。</li><li><code>description</code>：当前文件的详细介绍。</li></ul>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* createTime : 18-10-8 12:23</span></span><br><span class="line"><span class="comment">* description: 测试通知服务</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>方法注释 (可选)<br>  使用 <code>PHPdoc</code> 方式，描述方法功能、参数等。</p><ul><li><code>@param</code> 参数，语法：<code>@param [&quot;Type&quot;] [name] [&lt;description&gt;]</code>，标签用于记录函数或方法的单个参数，且可以有多行描述，不需要明确的分隔。</li><li><code>@return</code> 返回，语法：<code>@return &lt;&quot;Type&quot;&gt; [description]</code>，标签用于记录函数或方法的返回类型，同样支持多行描述。</li><li><code>@throws</code> 参数，语法：<code>@throws [Type] [&lt;description&gt;]</code>，标签用于记录函数或方法的抛出的错误异常，注明发生情况。</li></ul>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建商户 union_id</span></span><br><span class="line"><span class="comment"> * - 向 points_account 插入一条数据，获取 id</span></span><br><span class="line"><span class="comment"> * - 使用该 id 向 account base service 申请 union_id</span></span><br><span class="line"><span class="comment"> * - 更新记录</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $roleType 角色类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> PointsAccount 账号 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> \Throwable 生成 union_id 或者 创建账号失败抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">generateUnionIdAndCreateAccount</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$roleType</span></span>): <span class="title">PointsAccount</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变量注释 (可选)</p><ul><li><code>@var</code> 变量，语法：<code>@var [&quot;Type&quot;] [element_name] [&lt;description&gt;]</code>，标签用于记录变量类型，也用于记录常量等</li></ul>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> integer 待审核</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">STATUS_PENDING</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Vendor</span>\<span class="title class_">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Vendor</span>\<span class="title">Package</span>\&#123;<span class="title">ClassA</span> <span class="keyword">as</span> <span class="title">A</span>, <span class="title">ClassB</span>, <span class="title">ClassC</span> <span class="keyword">as</span> <span class="title">C</span>&#125;;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Vendor</span>\<span class="title">Package</span>\<span class="title">SomeNamespace</span>\<span class="title">ClassD</span> <span class="keyword">as</span> <span class="title">D</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">function</span> <span class="title">Vendor</span>\<span class="title">Package</span>\&#123;<span class="title">functionA</span>, <span class="title">functionB</span>, <span class="title">functionC</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">const</span> <span class="title">Vendor</span>\<span class="title">Package</span>\&#123;<span class="title">ConstantA</span>, <span class="title">ConstantB</span>, <span class="title">ConstantC</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Bar</span> <span class="keyword">implements</span> <span class="title">FooInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sampleFunction</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$a</span>, <span class="keyword">int</span> <span class="variable">$b</span> = <span class="literal">null</span></span>): <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$a</span> === <span class="variable">$b</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">bar</span>();</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="variable">$a</span> &gt; <span class="variable">$b</span>) &#123;</span><br><span class="line">            <span class="variable">$foo</span>-&gt;<span class="title function_ invoke__">bar</span>(<span class="variable">$arg1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title class_">BazClass</span>::<span class="title function_ invoke__">bar</span>(<span class="variable">$arg2</span>, <span class="variable">$arg3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;版本：v1.0&lt;br&gt;日期：2018-10-10&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于 MySQL InnoDB 引擎的索引知识</title>
    <link href="https://www.wewx.cn/2018/06/01/indexing-knowledge-about-the-mysql-innodb-engine.html"/>
    <id>https://www.wewx.cn/2018/06/01/indexing-knowledge-about-the-mysql-innodb-engine.html</id>
    <published>2018-06-01T00:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>这边文章在草稿箱放了整整１年半啊.</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>从 MySQL 5.5.5 版本开始 InnoDB 是 Mysql 的默认存储引擎。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="支持的索引"><a href="#支持的索引" class="headerlink" title="支持的索引"></a>支持的索引</h3><ul><li>支持全文索引</li><li>支持 B+ 树索引</li><li>支持 hash 索引</li></ul><p>其中 hash 索引是完全自动的，不能人工干预，InnoDB 引擎会监控表上各个索引页的查询，如果观察到建立 hash 索引可以带来速度提升，则自动建立 hash 索引</p><p><strong>B+ 树索引</strong><br>就是我们所说的索引。<br>B+ 树索引不能直接找到具体数据的行，只能找到数据所在的页，数据库通过把也度入到内存，在内存中查找，最后得到数据。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>二叉树：每个节点有两个子节点，数据量的增大必然导致高度的快速增加。<br>搜索二叉树：左子树小于根，右子树大于根。<br>平衡二叉树：2 棵子树的高度差为 1（查找效率共，但维护成本也高）。<br>B树：是一种自平衡的树。概括来说是一个一般化的二叉查找树，可以拥有多于 2 个子节点（也是 MyISAM  参考的数据结构，ISAM：索引顺序存取方法）。</p><p>B+ 树： 通过二叉查找树，再由平衡二叉树，B 树演化来的。因此，B+ 树也是一种平衡树。</p><p><img src="https://ws1.sinaimg.cn/large/006CUA5Vgy1fzme91elfej30m80a8q4h.jpg"></p><p>⤴️ 高度为2 每页可存放3条记录的B+树。</p><p>B+ 树元素自底向上插入。所有记录节点都是按键值的大小顺序存放在同一层叶子节点上，由各叶子节点指针进行连接。</p><h4 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+ 树的插入操作"></a>B+ 树的插入操作</h4><p>节点未满：直接插入。</p><p>节点已满：这时候需要分裂。当一个结点满时，分配一个新的结点，并将原结点中 1&#x2F;2 的数据复制到新结点，最后在父结点中增加新结点的指针；B+ 树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟节点的指针</p><h4 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+ 树的删除操作"></a>B+ 树的删除操作</h4><p>直接删除：如果不是 Page Index 节点，则直接删除。<br>删除 Page Index 节点： 直接删除，使用右边的节点作为 Page Index， 同事更新父节点。<br>合并：删除后，节点数量小于 50%，则和兄弟节点合并。同时更新父节点。</p><h4 id="B-树的查找"><a href="#B-树的查找" class="headerlink" title="B+ 树的查找"></a>B+ 树的查找</h4><p><img src="https://ws1.sinaimg.cn/large/006CUA5Vgy1fzmearrmt8j30fi04vwet.jpg" alt="B+ 树的查找示意图"></p><p>通常向下读取一个节点的动作可能会是一次磁盘IO操作，不过非叶节点通常会在初始阶段载入内存以加快访问速度。同时为提高在节点间横向遍历速度，真实数据库中可能会将图中蓝色的CPU计算&#x2F;内存读取优化成二叉搜索树。</p><h3 id="InnoDB-的索引"><a href="#InnoDB-的索引" class="headerlink" title="InnoDB 的索引"></a>InnoDB 的索引</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>InnoDB使用的是聚集索引，就是按照每张表的主键构建一颗B+树，叶子节点中存放的整张表的行记录数据（数据页）。各数据页之间使用双向链表连接。</p><p>聚集索引即是主键。<br>每张表只能有用一个聚集索引。<br>数据在逻辑上是顺序的，物理上不是顺序存储的。<br>聚集索引的排序、查找、范围查找非常快。</p><h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>也称非聚集索引。叶子节点不包含行记录的全部数据。叶子节点除了包含键值以外，还包含一个数钱，用来告诉引擎在哪里找到数据（指向到聚集索引）。<br>辅助索引不影响数据在聚集索引中的组织，因此，一张表可以包含多个辅助索引。</p><p>假设辅助索引树高3层，聚集索引树为3层。辅助索引 B+ 树中检索 name，需要先经过3次 IO 到达其叶子节点获取对应的主键。接着再经过3次 IO 使用主键在聚集索引 B+ 树中再执行一次 B+ 树检索操作，最终到达叶子节点即可获取整行数据。</p><p>聚簇索引的优势:</p><ul><li>行数据和叶子节点存储在一起，这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回。</li><li>保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。</li></ul><h2 id="正确建立索引"><a href="#正确建立索引" class="headerlink" title="正确建立索引"></a>正确建立索引</h2><ul><li><p>最左前缀匹配</p></li><li><p>&#x3D; 和 in 可以乱序， MySQL 的查询优化器会帮你优化成索引可以识别的形式</p></li><li><p>尽量选择区分度高的列作为索引（Cardinality 值），区分度的公式是  <code>count(distinct col)/count(*)</code> ，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1</p><ul><li><code>show index from user</code> 可查看 Cardinality 值（采样统计，非实时）</li><li><img src="https://ws1.sinaimg.cn/large/006CUA5Vgy1fzme9yvis3j31lg09mq58.jpg" alt="Cardinality 值"></li></ul></li><li><p>索引列不能参与计算</p></li><li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这边文章在草稿箱放了整整１年半啊.&lt;/p&gt;
&lt;h2 id=&quot;InnoDB&quot;&gt;&lt;a href=&quot;#InnoDB&quot; class=&quot;headerlink&quot; title=&quot;InnoDB&quot;&gt;&lt;/a&gt;InnoDB&lt;/h2&gt;&lt;p&gt;从 MySQL 5.5.5 版本开始 InnoDB 是 M</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="MySQL" scheme="https://www.wewx.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 分区表探索</title>
    <link href="https://www.wewx.cn/2017/12/08/mySQL-partitioned-table-exploration.html"/>
    <id>https://www.wewx.cn/2017/12/08/mySQL-partitioned-table-exploration.html</id>
    <published>2017-12-08T00:00:00.000Z</published>
    <updated>2022-11-16T02:27:30.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果需要定时清理一张普通大表里的历史数据。</p><p>可以使用一个或多个带 where 条件的 delete 语句去删除（where条件是时间）。 如果表数据量较大，这对数据库的造成了很大压力。即使我们把这些旧数据删除了，但是底层的数据文件并没有变小。</p><blockquote><p>为什么没有变小？<br>当删除数据 时，MYSQL 并不会立即回收表空间。被已删除数据的占据的存储空间，以及索引位会空在那里，等待新的数据来弥补这个空缺。<br>强行回收： OPTIMIZE TABLE</p></blockquote><p>面对这类问题，其实最有效的方法就是在使用分区表。分区表最大的优点就是可以非常高效的进行历史数据的清理。</p><h2 id="关于分区表"><a href="#关于分区表" class="headerlink" title="关于分区表"></a>关于分区表</h2><p>分区表不是在存储引擎层完成的。这是 MySQL 支持的功能（5.1开始）</p><p>原理：<br>将表索引分解为多个更小、更可管理的部分。</p><p>从逻辑上讲，只有一个表或者索引，但是物理上这个表或者索引可能由数十个物理分区组成。</p><p>分区表最大的优点就是可以非常高效的进行历史数据的清理。</p><p>每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理（如果分区表很大，亦可以将分区分配到不同的磁盘上去）。</p><p>在执行查询的时候，优化器会根据分区定义过滤哪些没有我们需要数据的分区，这样查询就无须全表扫描所有分区，只查找包含需要数据的分区即可。</p><h2 id="检查分区功能是否启用"><a href="#检查分区功能是否启用" class="headerlink" title="检查分区功能是否启用"></a>检查分区功能是否启用</h2><pre><code>mysql&gt; SHOW PLUGINS \G;*************************** 43. row ***************************   Name: partition Status: ACTIVE   Type: STORAGE ENGINELibrary: NULLLicense: GPL</code></pre><h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><p>MySQL目前只支持 水平分区（水平分区就是将不同的行分配到不同的物理文件中）。</p><ul><li><p>范围分区（RANGE）<br>行数据基于一个给定的连续区间的值被放入分区。</p></li><li><p>列表分区（LIST）<br>和 RANGE 分区类似，只不过面向的是离散的值。</p></li><li><p>哈希分区（HASH）<br>根据用户自定义的表达式返回的值来区分放入那个分区。</p></li><li><p>KEY分区<br>根据 MySQL 数据库提供的哈希函数来进行分区。</p></li><li><p>COLUMNS 分区<br>可以对多个列的值进行分区。（MySQL 5.5+ 开始支持）。</p></li></ul><h2 id="RANGE-分区"><a href="#RANGE-分区" class="headerlink" title="RANGE 分区"></a>RANGE 分区</h2><p>这是最常用的一种分区类型。最常见的是基于时间字段（基于分区的列最好是整型）来分区。<br>分区的列可以允许 null 值，如果分区的列值是 null，则会选择第一个分区。</p><pre><code>CREATE TABLE range_partition_test (    id INT,    pdate INT)PARTITION BY RANGE (pdate) (    PARTITION p1 VALUES LESS THAN ( 201702 ),    PARTITION p2 VALUES LESS THAN ( 201703 ),    PARTITION p3 VALUES LESS THAN ( 201704 ),    PARTITION p4 VALUES LESS THAN (MAXVALUE));</code></pre><p><code>MAXVALUE</code> 是一个无穷大的值，所以p4 分区即为默认的分区。</p><p>在执行查询的时候，带上分区字段，这样可以使用分区剪裁功能。</p><pre><code>mysql&gt; select * from range_partition_test;+------+--------+| id   | pdate  |+------+--------+|    1 | 201701 ||    2 | 201702 ||    3 | 201703 ||    4 | 201704 ||    5 | 201705 |+------+--------+mysql&gt; explain partitions select * from range_partition_test where pdate between 201702 and 201703;+----+-------------+----------------------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table                | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+----------------------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | range_partition_test | p2,p3      | ALL  | NULL          | NULL | NULL    | NULL |    2 |    50.00 | Using where |+----+-------------+----------------------+------------+------+---------------+------+---------+------+------+----------+-------------+</code></pre><p>只查询了p2,p3分区。</p><h2 id="LIST-分区"><a href="#LIST-分区" class="headerlink" title="LIST 分区"></a>LIST 分区</h2><p>LIST 分区和 RANGE 分区类似。<br>区别在于 LIST 是枚举值列表的集合，RANGE 是连续的区间值的集合。二者在语法方面非常的相似。<br>建议 LIST 分区列是非 null 列，否则插入 null 值如果枚举列表里面不存在 null 值会插入失败（和 RANGE 分区不一样）。</p><pre><code>CREATE TABLE list_partition_test (    id INT,    pdate INT)PARTITION BY LIST (pdate) (    PARTITION p1 VALUES IN (1,3,5,7,9),    PARTITION p2 VALUES IN (2,4,6,8,0));</code></pre><h2 id="Hash-分区"><a href="#Hash-分区" class="headerlink" title="Hash 分区"></a>Hash 分区</h2><p>HASH 分区的目的是讲数据均匀的分不到预先定义的各个分区中。保证各个分区的记录数量大体上都是一致的。</p><p>在实际工作中经常遇到像会员表的这种表。并没有明显可以分区的特征字段。但表数据有非常庞大。这时候可以使用 HASH 分区。</p><p>基于给定的分区个数，将数据分配到不同的分区，HASH分区只能针对整数进行 HASH。</p><pre><code>CREATE TABLE hash_partition_test (    id INT,    pdate INT)PARTITION BY HASH(id)PARTITIONS 4;</code></pre><ul><li>上面的分区对象(id)也可以是一个表达式，表达式的结果必须是整数值。</li><li>HASH 分区可以不用指定 PARTITIONS 子句，则默认分区数为1。</li><li>不允许只写 PARTITIONS，而不指定分区数。</li><li>HASH 分区的底层实现其实是基于 MOD 函数。</li></ul><h2 id="KEY-分区"><a href="#KEY-分区" class="headerlink" title="KEY 分区"></a>KEY 分区</h2><p>KEY 分区和 HASH 分区相似。不同之处在于：</p><ul><li>KEY 分区允许多列，而 HASH 分区只允许一列。</li><li>如果在有主键或者唯一键的情况下，key 中分区列可不指定，默认为主键或者唯一键，如果没有，则必须显性指定列。</li><li>KEY 分区对象必须为列，而不能是基于列的表达式。</li><li>KEY 分区和 HASH 分区的算法不一样，对于 innodb 引擎，采用的是 MD5 值来分区。</li></ul><h2 id="COLUMNS-分区"><a href="#COLUMNS-分区" class="headerlink" title="COLUMNS 分区"></a>COLUMNS 分区</h2><p>可以直接使用非整型的数据进行分区。分区根据类型直接比较而得，不需要转化为整型。同时，可以对多个列值进行分区。</p><pre><code>CREATE TABLE listvardou (    id INT,    pdate INT)PARTITION BY LIST COLUMNS(id,pdate)(    PARTITION a VALUES IN ( (1, 201701), (1, 201702), (1, 201703)),    PARTITION b VALUES IN ( (2, 201702) )    PARTITION b VALUES IN ( (3, 201703) ));</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>RANGE 分区，LIST 分区，HASH 分区，KEY 分区对象返回的只能是整数值，如果不是整型，则需要使用函数将其转化为整型。</li><li>数据表非常大以至于无法全部都放到内存，或者只在表的最后部分有热点数据，其他均为历史数据的情况下，可以选用分区表。</li><li>分区表数据更容易维护（可独立对分区进行优化、检查、修复及批量删除大数据可以采用drop分区的形式等）。</li><li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。</li><li>可以备份和恢复独立的分区，非常适用于大数据集的场景。</li><li>分区的主要目的是用于数据库的高可用性管理。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;如果需要定时清理一张普通大表里的历史数据。&lt;/p&gt;
&lt;p&gt;可以使用一个或多个带 where 条件的 delete 语句去删除（where条件</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.wewx.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="MySQL" scheme="https://www.wewx.cn/tags/MySQL/"/>
    
  </entry>
  
</feed>
